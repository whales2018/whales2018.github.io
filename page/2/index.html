<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>沧海一粟</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="沧海一粟">
<meta property="og:url" content="https://whales2018.github.io/page/2/index.html">
<meta property="og:site_name" content="沧海一粟">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="沧海一粟">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">沧海一粟</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://whales2018.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-mysql-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-4/" class="article-date">
  <time datetime="2018-06-30T06:00:01.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《高性能MySQL》阅读笔记/">《高性能MySQL》阅读笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-4/">《高性能MySQL》阅读笔记四</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-查询性能优化"><a href="#1-查询性能优化" class="headerlink" title="1. 查询性能优化"></a>1. 查询性能优化</h1><h2 id="1-1-优化数据访问"><a href="#1-1-优化数据访问" class="headerlink" title="1.1 优化数据访问"></a>1.1 优化数据访问</h2><ol>
<li>检查是否检索大量超过需要的数据.是否访问太多行或太多列,增加网络开销,消耗cpu和内存资源</li>
<li>检查服务器层是否在分析大量超过需要的数据行</li>
</ol>
<h2 id="1-2-重构查询的方式"><a href="#1-2-重构查询的方式" class="headerlink" title="1.2 重构查询的方式"></a>1.2 重构查询的方式</h2><h3 id="1-2-1-切分查询"><a href="#1-2-1-切分查询" class="headerlink" title="1.2.1 切分查询"></a>1.2.1 切分查询</h3><ol>
<li>有时对于一个大查询我们需要分而治之,切分成小查询每次只完成一部分</li>
</ol>
<h3 id="1-2-2-分解关联查询"><a href="#1-2-2-分解关联查询" class="headerlink" title="1.2.2 分解关联查询"></a>1.2.2 分解关联查询</h3><ol>
<li>缓存效率更高: 方便缓存单表查询结果</li>
<li>执行单个查询可以减少锁的竞争</li>
<li>在应用层做关联，更容易对数据库进行拆分，更容易做到高性能和可扩展</li>
<li>使用in　代替关联查询可能比随机的关联要高效</li>
<li>可以减少冗余记录的查询</li>
</ol>
<h2 id="1-3-查询执行的基础"><a href="#1-3-查询执行的基础" class="headerlink" title="1.3 查询执行的基础"></a>1.3 查询执行的基础</h2><h3 id="1-3-1-查询流程"><a href="#1-3-1-查询流程" class="headerlink" title="1.3.1 查询流程"></a>1.3.1 查询流程</h3><ol>
<li>先检查缓存</li>
<li>sql解析,预处理,优化器生成相应的执行计划</li>
<li>调用存储引擎的api执行查询</li>
</ol>
<h3 id="1-3-2-通信协议"><a href="#1-3-2-通信协议" class="headerlink" title="1.3.2 通信协议"></a>1.3.2 通信协议</h3><ol>
<li>半双工,任何一时刻要么是服务器向客户端发送数据,要么是客户端向服务端发送数据</li>
<li>客户端从服务器获取数据时,实际是MySQL向客户端推送数据的过程</li>
</ol>
<h3 id="1-3-3-查询状态"><a href="#1-3-3-查询状态" class="headerlink" title="1.3.3 查询状态"></a>1.3.3 查询状态</h3><ol>
<li>Ｓleep: 线程正在等待客户端发送新的请求</li>
<li>Query: 线程正在执行查询或者正在将结果发送给客户端</li>
<li>Locked: 服务器层,线程正在等待表锁</li>
<li>Analyzing and statistics: 线程正在收集存储引擎统计信息,并生成查询的执行计划</li>
<li>Copying to tmp table: 线程正在执行查询,并且将结果集复制到一个临时表中.常见group by或文件排序操作</li>
<li>Sorting result: 线程正在对结果进行排序</li>
<li>Sending data: 线程可能在多个状态之间传送数据或在生成结果集或向客户端返回数据</li>
</ol>
<h3 id="1-3-4-查询优化"><a href="#1-3-4-查询优化" class="headerlink" title="1.3.4 查询优化"></a>1.3.4 查询优化</h3><h4 id="1-3-4-1-语法解析器和预处理"><a href="#1-3-4-1-语法解析器和预处理" class="headerlink" title="1.3.4.1 语法解析器和预处理"></a>1.3.4.1 语法解析器和预处理</h4><ol>
<li>通过关键字将sql语句进行解析,生成对应的解析树</li>
<li>解析器使用语法规则验证和解析查询</li>
<li>预处理器进一步检查解析树是否合法,验证权限</li>
</ol>
<h4 id="1-3-4-2-查询优化器"><a href="#1-3-4-2-查询优化器" class="headerlink" title="1.3.4.2 查询优化器"></a>1.3.4.2 查询优化器</h4><ol>
<li>一条查询可以有多种执行方式,优化器找到其中最好的执行计划,MySQL使用基于成本的优化器</li>
<li>优化类型</li>
<li>重新定义关联表的顺序</li>
<li>外联结转化成内连接</li>
<li>使用等价变换规则</li>
<li>优化count, min, max函数</li>
<li>预估并转化为常数表达式</li>
<li>覆盖索引扫描</li>
<li>子查询优化</li>
<li>提前终止查询,如limit</li>
<li>等值传播</li>
<li>In优化</li>
</ol>
<h4 id="1-3-4-3-关联查询"><a href="#1-3-4-3-关联查询" class="headerlink" title="1.3.4.3 关联查询"></a>1.3.4.3 关联查询</h4><ol>
<li>嵌套循环: 先在一个表中循环取出单条数据,然后再嵌套循环到下一个表中寻找匹配的行,如果最后一个联表无法找到更多的行,则返回上一层次关联表</li>
<li>UNION查询和子查询时都会将临时结果存放到一个临时表中</li>
</ol>
<h4 id="1-3-4-4-执行计划"><a href="#1-3-4-4-执行计划" class="headerlink" title="1.3.4.4 执行计划"></a>1.3.4.4 执行计划</h4><ol>
<li>MySQL生成一棵指令树,通过存储引擎执行完成并返回结果</li>
</ol>
<h4 id="1-3-4-5-排序优化"><a href="#1-3-4-5-排序优化" class="headerlink" title="1.3.4.5 排序优化"></a>1.3.4.5 排序优化</h4><ol>
<li>排序是一个成本很高的操作</li>
<li>MySQL排序: 如果数据量小,则在内存中进行; 数据量大则先分块再排序再合并</li>
<li>MySQL4.1后使用单次传输排序: 先读取查询所需要的所有列,再根据给定列排序</li>
</ol>
<h4 id="1-3-4-6-查询执行引擎"><a href="#1-3-4-6-查询执行引擎" class="headerlink" title="1.3.4.6 查询执行引擎"></a>1.3.4.6 查询执行引擎</h4><ol>
<li>根据执行计划的指令逐步执行</li>
</ol>
<h4 id="1-3-4-7-返回结果给客户端"><a href="#1-3-4-7-返回结果给客户端" class="headerlink" title="1.3.4.7 返回结果给客户端"></a>1.3.4.7 返回结果给客户端</h4><ol>
<li>如果查询可以缓存,则缓存在这个阶段进行</li>
<li>返回结果的过程是一个增量逐步返回的过程,一旦开始生成第一条结果时就可以开始向客户端返回结果集</li>
</ol>
<h2 id="1-4-查询优化器的局限"><a href="#1-4-查询优化器的局限" class="headerlink" title="1.4 查询优化器的局限"></a>1.4 查询优化器的局限</h2><ol>
<li>子查询相对糟糕(不是绝对),如子查询用in</li>
<li>联表查询与子查询根据场景不同有不同优势</li>
<li>MySQL无法将限制条件下推到子查询</li>
<li>索引合并优化</li>
<li>MySQL无法利用多核特性并行执行查询</li>
<li>MySQL并不支持哈希关联, MariaDB已经实现了真正的哈希关联  </li>
<li>松散索引扫描,无法按照不连续的方式扫描一个索引</li>
<li>最大值最小值函数的优化一般</li>
<li>不允许同一张表上同时查询和更新, 如update set 等于 select 自己.解决方法,可以通过关联临时表</li>
</ol>
<h2 id="1-5-查询优化器的提示"><a href="#1-5-查询优化器的提示" class="headerlink" title="1.5 查询优化器的提示"></a>1.5 查询优化器的提示</h2><ol>
<li>设置查询优化器参数,可以阅读官方手册</li>
<li>一般除非需要,修改查询优化器参数会提高维护成本</li>
</ol>
<h2 id="1-6-优化特定类型的查询"><a href="#1-6-优化特定类型的查询" class="headerlink" title="1.6 优化特定类型的查询"></a>1.6 优化特定类型的查询</h2><ol>
<li>关联查询: on的列加索引; 使用group by和order by 只使用一个表的列可以利用索引</li>
<li>优化LIMIT分页: 尽量使用覆盖索引</li>
<li>子查询: 尽量使用关联查询替换</li>
<li>静态查询分析: Percona Toolkit中的pt-query-advisor能解析查询日志,分析查询模式</li>
<li>使用用户自定义变量: 无法使用查询缓存,可能被优化器优化掉</li>
</ol>
<h1 id="2-MySQL高级特性"><a href="#2-MySQL高级特性" class="headerlink" title="2. MySQL高级特性"></a>2. MySQL高级特性</h1><h2 id="2-1-分区表"><a href="#2-1-分区表" class="headerlink" title="2.1 分区表"></a>2.1 分区表</h2><h3 id="2-1-1-应用"><a href="#2-1-1-应用" class="headerlink" title="2.1.1 应用"></a>2.1.1 应用</h3><ol>
<li>表非常大无法全部放在内存中,或者只在表的最后部分有热点数据其他均是历史数据</li>
<li>分区表的数据更容易维护</li>
<li>分区表的数据可以分布在不同的物理设备上</li>
<li>使用分区表避免某些瓶颈,如InnoDB单个索引的互斥访问</li>
<li>备份和恢复独立分区,对于大数据集效果较好</li>
</ol>
<h3 id="2-1-2限制"><a href="#2-1-2限制" class="headerlink" title="2.1.2限制"></a>2.1.2限制</h3><ol>
<li>一个表最多1024个分区</li>
<li>分区表达式必须是整数或返回整数的表达式</li>
<li>如果分区字段有主键或唯一索引列,那么所有主键列和唯一索引都必须包含进来</li>
<li>分区表中无法使用外键约束</li>
</ol>
<h3 id="2-1-3-原理"><a href="#2-1-3-原理" class="headerlink" title="2.1.3 原理"></a>2.1.3 原理</h3><ol>
<li>分区表由多个相关的底层表实现,存储引擎管理它们跟管理普通表一样</li>
<li>select 查询: 分区层打开并锁住所有底层表,优化器判断是否过滤分区,在调用存储引擎api访问各个分区数据</li>
<li>insert: 分区层打开并锁住所有底层表,确定分区,写入</li>
<li>delete: 分区层打开并锁住所有底层表,确定数据所在分区,删除</li>
<li>update: 分区层打开并锁住所有底层表,确定分区,取出数据,更新,确定分区,写入</li>
<li>打开并锁住所有底层表: 如果存储引擎实现行级锁如InnoDB,则会在分区层释放表锁</li>
</ol>
<h3 id="2-1-4-分区表类型"><a href="#2-1-4-分区表类型" class="headerlink" title="2.1.4 分区表类型"></a>2.1.4 分区表类型</h3><ol>
<li>根据范围进行分区: 每个分区储存落在某个范围的记录</li>
<li>根据键值进行分区,减少InnoDB互斥量竞争</li>
<li>使用数学模函数进行分区,然后将数据轮询放入不同的分区,适用于只想保留几天的数据</li>
</ol>
<h3 id="2-1-5-使用"><a href="#2-1-5-使用" class="headerlink" title="2.1.5 使用"></a>2.1.5 使用</h3><ol>
<li>问题回顾:数据量很大时,除非是索引覆盖查询,否则数据库需要根据索引扫描回表查询,产生大量的随机IO,数据库响应时间很大</li>
<li>全量扫描数据不要索引,根据分区定位数据位置</li>
<li>索引数据,分离热点. 将热点数据单独放在一个分区</li>
<li>NULL值会使分区过滤无效: 分区表达式接收NULL值并将其放到第一个分区导致查询时多查分区.解决方法:创建第一个无用分区存放NULL值数据</li>
<li>分区列和索引列不匹配,查询无法进行分区过滤</li>
<li>选择分区成本高,插入大量数据时都需要扫描分区定义找到分区</li>
<li>打开并锁住所有底层表的成本可能很高</li>
<li>维护分区的成本很高,同alter一样创建临时表然后拷贝数据</li>
<li>所有分区都必须使用相同的存储引擎</li>
</ol>
<h3 id="2-1-6-查询优化"><a href="#2-1-6-查询优化" class="headerlink" title="2.1.6 查询优化"></a>2.1.6 查询优化</h3><ol>
<li>在where条件带入分区列</li>
<li>创建分区时可以使用表达式,但是查询时只能在使用分区列本身进行比较时才能过滤分区,而不能根据表达式的值过滤分区</li>
</ol>
<h2 id="2-2-视图"><a href="#2-2-视图" class="headerlink" title="2.2 视图"></a>2.2 视图</h2><p>视图本身是一个虚拟表,不存放任何数据,不能对视图创建触发器</p>
<h3 id="2-2-1-算法"><a href="#2-2-1-算法" class="headerlink" title="2.2.1 算法"></a>2.2.1 算法</h3><ol>
<li>合并算法: 将存放的视图sql和用户发起的查询sql合并后执行</li>
<li>临时表算法: 由存放的视图sql先创建临时表后根据用户的查询sql查询返回</li>
</ol>
<h3 id="2-2-2-可更新视图"><a href="#2-2-2-可更新视图" class="headerlink" title="2.2.2 可更新视图"></a>2.2.2 可更新视图</h3><ol>
<li>可以通过更新视图更新相关表, 所有临时表算法实现的视图都无法更新</li>
</ol>
<h3 id="2-2-3-视图对性能的影响"><a href="#2-2-3-视图对性能的影响" class="headerlink" title="2.2.3 视图对性能的影响"></a>2.2.3 视图对性能的影响</h3><ol>
<li>一般情况视图不能提升性能,在某些情况下可以帮助提升性能,需要做比较详细的测试</li>
<li>视图还可以实现基于列的权限控制不用真正创建列权限</li>
</ol>
<h3 id="2-2-4-视图的限制"><a href="#2-2-4-视图的限制" class="headerlink" title="2.2.4 视图的限制"></a>2.2.4 视图的限制</h3><ol>
<li>不保存视图定义的原始sql语句</li>
<li>查看视图创建的语句,可以通过使用视图的.frm文件的最后一行获取一些信息</li>
</ol>
<h2 id="2-3-外键约束"><a href="#2-3-外键约束" class="headerlink" title="2.3 外键约束"></a>2.3 外键约束</h2><ol>
<li>InnoDB强制外键使用索引</li>
<li>查询需要额外访问一些表,需要额外的锁容易导致一些死锁</li>
<li>如果使用外键做约束,通常在应用程序里实现会更好</li>
</ol>
<h2 id="2-4-内部存储代码"><a href="#2-4-内部存储代码" class="headerlink" title="2.4 内部存储代码"></a>2.4 内部存储代码</h2><h3 id="2-4-1-优点"><a href="#2-4-1-优点" class="headerlink" title="2.4.1 优点"></a>2.4.1 优点</h3><ol>
<li>离数据最近,节省带宽和网络延迟</li>
<li>帮助提升安全性,应用程序可以通过存储过程访问那些没有权限的表</li>
<li>服务器端可以缓存存储过程的执行计划</li>
<li>维护方便,便于分工</li>
</ol>
<h3 id="2-4-2-缺点"><a href="#2-4-2-缺点" class="headerlink" title="2.4.2 缺点"></a>2.4.2 缺点</h3><ol>
<li>调试困难,难以定位问题</li>
<li>存储代码效率相对差</li>
<li>增加维护复杂性,存储过程会给数据库服务器增加额外压力</li>
<li>存在安全隐患,没有什么选项可以控制存储程序的资源消耗,所以一个小错误可能直接把服务器拖死</li>
</ol>
<h3 id="2-4-3-存储过程和函数"><a href="#2-4-3-存储过程和函数" class="headerlink" title="2.4.3 存储过程和函数"></a>2.4.3 存储过程和函数</h3><ol>
<li>优化器无法评估存储函数的执行成本</li>
<li>每个连接都有独立的存储过程的执行计划缓存,多个连接调用同一个存储过程会浪费缓存空间反复缓存同样的执行计划</li>
</ol>
<h3 id="2-4-4-触发器"><a href="#2-4-4-触发器" class="headerlink" title="2.4.4 触发器"></a>2.4.4 触发器</h3><ol>
<li>每个表的每个事件只能一个</li>
<li>MySQL只支持基于行的触发,如果变更的数据集非常庞大的化效率会很低</li>
<li>触发器的问题很难排查</li>
<li>可能导致死锁和锁等待</li>
<li>实现一些约束,系统维护任务及更新反范式化数据的时候会比较有用</li>
</ol>
<h3 id="2-4-5-事件"><a href="#2-4-5-事件" class="headerlink" title="2.4.5 事件"></a>2.4.5 事件</h3><ol>
<li>类似Linux的定时任务</li>
</ol>
<h2 id="2-5-游标"><a href="#2-5-游标" class="headerlink" title="2.5 游标"></a>2.5 游标</h2><ol>
<li>MySQL在服务器端提供只读的,单向的游标</li>
<li>一个存储过程中可以有多个游标,也可以嵌套</li>
</ol>
<h2 id="2-6-绑定变量"><a href="#2-6-绑定变量" class="headerlink" title="2.6 绑定变量"></a>2.6 绑定变量</h2><ol>
<li>创建一个绑定变量sql时客户端向服务器发送了一个sql语句原型</li>
<li>服务器端解析并存储这个sql语句的部分执行计划返回客户端一个sql语句处理句柄</li>
<li>可以使用问号作为sql的占位,在使用sql接口执行时赋予变量值</li>
</ol>
<h2 id="2-7-插件"><a href="#2-7-插件" class="headerlink" title="2.7 插件"></a>2.7 插件</h2><ol>
<li>存储过程插件</li>
<li>后台插件: 如Percona Server中包含的Handler-Socket</li>
<li>INFORMATION_SCHEMA插件</li>
<li>全文解析插件: 可以对文档进行分词处理</li>
<li>审计插件: 可以用作记录事件日志</li>
<li>认证插件: 扩展认证功能</li>
</ol>
<h2 id="2-8-字符集和校对"><a href="#2-8-字符集和校对" class="headerlink" title="2.8 字符集和校对"></a>2.8 字符集和校对</h2><ol>
<li>字符集是指一种从二进制编码到某类字符符号的映射</li>
<li>校对是指一组用于某个字符集的排序规则<h3 id="2-8-1-创建对象时的默认设置"><a href="#2-8-1-创建对象时的默认设置" class="headerlink" title="2.8.1 创建对象时的默认设置"></a>2.8.1 创建对象时的默认设置</h3></li>
<li>服务器,数据库,表都有默认的字符集和校对规则,这是一个逐层继承的默认设置</li>
<li>创建数据库时根据character_set_server设置来设定默认字符集</li>
</ol>
<h3 id="2-8-2-服务器和客户端通信设置"><a href="#2-8-2-服务器和客户端通信设置" class="headerlink" title="2.8.2 服务器和客户端通信设置"></a>2.8.2 服务器和客户端通信设置</h3><ol>
<li>服务端总是假设客户端按照character_set_client设置的字符来传输数据和sql语句</li>
<li>服务器端收到sql语句后根据character_set_connection转换成字符串</li>
<li>服务器端返回数据时会将其转换为character_set_result</li>
</ol>
<h3 id="2-8-3-选择字符集和校对规则"><a href="#2-8-3-选择字符集和校对规则" class="headerlink" title="2.8.3 选择字符集和校对规则"></a>2.8.3 选择字符集和校对规则</h3><ol>
<li>极简原则: 先为服务器选择合理的字符集在根据实际情况让某些列选择合适的字符集</li>
</ol>
<h3 id="2-8-4-对查询的影响"><a href="#2-8-4-对查询的影响" class="headerlink" title="2.8.4 对查询的影响"></a>2.8.4 对查询的影响</h3><ol>
<li>不同字符集和校对规则之间的转换会带来额外的开销</li>
<li>排序查询要求的字符集与服务器数据的字符集相同时才能利用索引进行排序</li>
<li>当两个字符集不同列关联两个表时,MySQL会尝试转换其中一个列的字符集</li>
</ol>
<h2 id="2-9-全文索引"><a href="#2-9-全文索引" class="headerlink" title="2.9 全文索引"></a>2.9 全文索引</h2><ol>
<li>自然语言的全文索引: 相关度是基于匹配的关键词个数及关键词在文档中出现的次数,整个索引中出现次数越少的词语匹配的相关度越高</li>
<li>布尔全文索引: 只有MyISAM才能使用</li>
<li>平时没接触过,有兴趣者请自行google</li>
</ol>
<h2 id="2-10-分布式XA事务"><a href="#2-10-分布式XA事务" class="headerlink" title="2.10 分布式XA事务"></a>2.10 分布式XA事务</h2><ol>
<li>事务协调器保证所有事务参与者完成工作,通知所有事务提交</li>
<li>内部XA事务: 存储引擎提交的同时,需要将提交的信息写入二进制日志</li>
<li>外部XA事务: XA事务是一种在多个服务器之间同步数据的方法,如果由于不能使用MySQL本身的复制或者性能并不是瓶颈可以尝试使用</li>
</ol>
<h2 id="2-11-查询缓存"><a href="#2-11-查询缓存" class="headerlink" title="2.11 查询缓存"></a>2.11 查询缓存</h2><ol>
<li>查询缓存系统会跟踪查询中涉及的每个表,如果表发生变化则缓存数据失效</li>
<li>缓存存放在一个引用表中,通过一个哈希值引用,哈希值包括查询本身,查询数据库等信息</li>
<li>当sql语句和客户端发送过来的其他原始信息,任何字符上的不同都会导致缓存不命中</li>
<li>打开查询缓存对读和写都会带来额外的消耗</li>
<li>InnoDB事务修改表时,会将这个表对应的查询缓存都设置失效</li>
<li>查询缓存被发现是一个影响服务器扩展性的因素</li>
<li>如果缓存了大量的查询结果,那么失效操作可能会造成系统僵死.因为靠一个全局锁保护,所有该操作都要等锁</li>
<li>减少碎片, 选择合适的query_cache_min_res_unit可以减少内存浪费</li>
<li>对于写密集型的应用,直接禁用更好</li>
<li>高并发环境也不适合.只有明确缓存的好处才使用</li>
<li>查询缓存的替代方案: 客户端缓存</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-4/" data-id="cjsa69doz000or3zlawf3mrux" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-3/" class="article-date">
  <time datetime="2018-06-30T05:53:23.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《高性能MySQL》阅读笔记/">《高性能MySQL》阅读笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-3/">《高性能MySQL》阅读笔记三</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-schema与数据类型优化"><a href="#1-schema与数据类型优化" class="headerlink" title="1. schema与数据类型优化"></a>1. schema与数据类型优化</h1><h2 id="1-1-数据类型选择"><a href="#1-1-数据类型选择" class="headerlink" title="1.1 数据类型选择"></a>1.1 数据类型选择</h2><p>更小: 选择不超过需求范围的最小类型</p>
<p>更简单</p>
<p>避免使用Null: 含有Null列会使索引,索引统计和值更为复杂</p>
<p>分配空间: 根据实际需要分配.使用内存临时表或操作时会比较糟糕</p>
<p>特殊类型:书中举例,ip地址应该用无符号整数存储,MySQL提供inet_aton, inet_ntoa方法转换</p>
<h2 id="1-2-schema-设计陷阱"><a href="#1-2-schema-设计陷阱" class="headerlink" title="1.2 schema 设计陷阱"></a>1.2 schema 设计陷阱</h2><ol>
<li><p>太多列,存储引擎api需要在服务器层和存储引擎层通过行缓冲格式拷贝数据,然后解码.转换代价依赖于列的数量</p>
</li>
<li><p>太多的关联,单个查询最好在12个表以内</p>
</li>
<li><p>最好不用枚举enum</p>
</li>
<li><p>可以使用其他”空值”替代Null</p>
</li>
</ol>
<h2 id="1-3-范式和反范式"><a href="#1-3-范式和反范式" class="headerlink" title="1.3 范式和反范式"></a>1.3 范式和反范式</h2><ol>
<li><p>范式化: 每个事实数据只出现一次</p>
</li>
<li><p>反范式化: 信息是冗余的</p>
</li>
<li><p>第一范式1NF: 关系中的每个属性都不可再分</p>
</li>
<li><p>第二范式2NF: 每个表中的非主属性完全依赖于码(例如主键, 可以唯一决定属性集合)</p>
</li>
<li><p>第三范式3NF: 消除非主属性之间的依赖关系，只保留非主属性与码的依赖关系</p>
</li>
<li><p>范式化优点: 更新操作更快,占用空间更小</p>
</li>
<li><p>范式化缺点: 表的关联查询更多</p>
</li>
<li><p>混用范式和反范式: 从父表冗余一些数据到子表有利于排序, 缓存衍生值减少子查询计算</p>
</li>
</ol>
<h2 id="1-4-缓存表和汇总表"><a href="#1-4-缓存表和汇总表" class="headerlink" title="1.4 缓存表和汇总表"></a>1.4 缓存表和汇总表</h2><p>业务上有时需要一张完全独立的汇总表或缓存表主要用于满足检索的需求</p>
<ol>
<li><p>Flexviews实现物化视图,可以增量重新计算物化视图的内容</p>
</li>
<li><p>计数器表: 如果需要在表中保存计数器,更新计数器时,会有全局的互斥锁.要获的高并发更新的性能,可以将计数器保存在多行,每次随机选择一个进行更新</p>
</li>
</ol>
<h2 id="1-5-修改表结构"><a href="#1-5-修改表结构" class="headerlink" title="1.5 修改表结构"></a>1.5 修改表结构</h2><ol>
<li><p>大部分的alter table操作将导致服务中断</p>
</li>
<li><p>所有的modify column 操作都将导致表重建</p>
</li>
<li><p>可以新建一个.frm文件为修改后的表结构,替换原来的.frm文件避免表重建</p>
</li>
</ol>
<h1 id="2-创建高性能的索引"><a href="#2-创建高性能的索引" class="headerlink" title="2. 创建高性能的索引"></a>2. 创建高性能的索引</h1><p>索引是存储引擎用于快速查找记录的数据结构</p>
<h2 id="2-1-索引基础"><a href="#2-1-索引基础" class="headerlink" title="2.1 索引基础"></a>2.1 索引基础</h2><p>MySQL中,存储引擎先在索引中找到对应值根据匹配的索引记录找到对应的数据行.索引在存储引擎层实现</p>
<h3 id="2-1-1-B-Tree索引"><a href="#2-1-1-B-Tree索引" class="headerlink" title="2.1.1 B-Tree索引"></a>2.1.1 B-Tree索引</h3><ol>
<li><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构. </p>
</li>
<li><p>InnoDB使用B+Tree, NDB集群存储引擎实际使用T-Tree. 索引对多个值的排序一句是根据表定义索引时列的顺序.</p>
</li>
<li><p>索引对如下类型的查询有效</p>
</li>
<li><p>全值匹配</p>
</li>
<li><p>匹配最左前缀,只使用索引第一列</p>
</li>
<li><p>匹配列前缀: 只匹配某一列值的开头部分</p>
</li>
<li><p>匹配范围值</p>
</li>
<li><p>精确匹配某一列并范围匹配另外一列</p>
</li>
<li><p>只访问索引的查询: 查询只需要访问索引无需访问数据行(覆盖扫描)</p>
</li>
<li><p>限制</p>
</li>
<li><p>如果不是按照索引的最左列开始,则无法使用索引</p>
</li>
<li><p>不能跳过索引中的列,即定义索引(a,b,c),则使用a,c查询条件时,只能使用索引第一列</p>
</li>
<li><p>如果查询中有某个列的范围查询,则右边所有的列都无法使用索引优化查找</p>
</li>
</ol>
<h3 id="2-1-2-哈希索引"><a href="#2-1-2-哈希索引" class="headerlink" title="2.1.2 哈希索引"></a>2.1.2 哈希索引</h3><ol>
<li><p>对于每一行数据,存储引擎会对索引列计算一个哈希码.索引包含哈希码和行指针</p>
</li>
<li><p>MySQL中只有Memory存储引擎支持</p>
</li>
<li><p>限制</p>
</li>
<li><p>不能使用索引中的值避免读取行</p>
</li>
<li><p>无法用于排序</p>
</li>
<li><p>不支持部分索引列匹配查找</p>
</li>
<li><p>不支持范围查询</p>
</li>
<li><p>出现哈希冲突时会扫表</p>
</li>
</ol>
<h3 id="2-1-3-伪哈希索引"><a href="#2-1-3-伪哈希索引" class="headerlink" title="2.1.3 伪哈希索引"></a>2.1.3 伪哈希索引</h3><ol>
<li><p>应用: 当存储引擎不支持哈希索引,在B-Tree基础上使用哈希值索引查找</p>
</li>
<li><p>场景: 需要存储大量的url并根据url进行搜索查找</p>
</li>
<li><p>问题: 如果使用B-Tree存储,内容很大</p>
</li>
<li><p>方案: 删除url列索引,新增一个被索引的url_crc列,使用CRC32做哈希.</p>
</li>
<li><p>sql: select id from t_url where url=”<a href="https://www.google.as/&quot;" target="_blank" rel="noopener">https://www.google.as/&quot;</a> and url_crc=CRC32(“<a href="https://www.google.as/&quot;" target="_blank" rel="noopener">https://www.google.as/&quot;</a>)</p>
</li>
<li><p>结果: MySQL优化器会使用选择性很高体积很小的基于url_crc索引完成查找</p>
</li>
<li><p>缺陷: 需要维护哈希值, crc32表大时会出现大量冲突</p>
</li>
<li><p>注意: 不要使用SHA1和MD5做哈希函数,因为计算出来的哈希值比较长; 必须在where子句中包含常量</p>
</li>
<li><p>插件: 移植自Percona Server的FNV64可以在MySQL中作为哈希函数使用</p>
</li>
</ol>
<h3 id="2-1-4-空间数据索引-R-Tree"><a href="#2-1-4-空间数据索引-R-Tree" class="headerlink" title="2.1.4 空间数据索引(R-Tree)"></a>2.1.4 空间数据索引(R-Tree)</h3><ol>
<li>MyISAM表支持空间索引,可以用作地理数据存储</li>
</ol>
<h3 id="2-1-5-全文索引"><a href="#2-1-5-全文索引" class="headerlink" title="2.1.5 全文索引"></a>2.1.5 全文索引</h3><ol>
<li>全文索引是一种特殊类型索引,查找文本中的关键词,后续讨论</li>
</ol>
<h3 id="2-1-6-其他"><a href="#2-1-6-其他" class="headerlink" title="2.1.6 其他"></a>2.1.6 其他</h3><ol>
<li><p>TokuDB 使用分形树索引, 对于InnoDB的讨论也适用于TokuDB</p>
</li>
<li><p>ScaleDB 使用Patricia tries</p>
</li>
<li><p>InfiniDB和Infobright使用一些特殊的数据结构优化某些特殊的查询</p>
</li>
</ol>
<h2 id="2-2索引的优点"><a href="#2-2索引的优点" class="headerlink" title="2.2索引的优点"></a>2.2索引的优点</h2><ol>
<li><p>减少扫描数据量</p>
</li>
<li><p>避免排序和临时表</p>
</li>
<li><p>将随机I/O变成顺序I/O</p>
</li>
<li><p>对于TB级别的数据,经常会使用块级别的数据技术来替代索引</p>
</li>
</ol>
<h2 id="2-3-高性能的索引策略"><a href="#2-3-高性能的索引策略" class="headerlink" title="2.3 高性能的索引策略"></a>2.3 高性能的索引策略</h2><h3 id="2-3-1-独立的列"><a href="#2-3-1-独立的列" class="headerlink" title="2.3.1 独立的列"></a>2.3.1 独立的列</h3><ol>
<li>索引列不能是表达式一部分或函数参数,否则不能使用索引</li>
</ol>
<h3 id="2-3-2-前缀索引"><a href="#2-3-2-前缀索引" class="headerlink" title="2.3.2 前缀索引"></a>2.3.2 前缀索引</h3><ol>
<li><p>场景: 需要索引很长的字符列,这会让索引变得大且慢</p>
</li>
<li><p>方案: 根据业务找到最适合的前缀长度,创建前缀索引</p>
</li>
<li><p>优点: 索引更小,更快</p>
</li>
<li><p>缺点: MySQL无法使用前缀索引order by 和group by,也无法使用前缀索引做覆盖扫描</p>
</li>
<li><p>常见: 用16进制唯一id存储session id,如果采用长度为8的前缀索引能显著提升性能</p>
</li>
</ol>
<h3 id="2-3-3-多列索引"><a href="#2-3-3-多列索引" class="headerlink" title="2.3.3 多列索引"></a>2.3.3 多列索引</h3><ol>
<li><p>MySQL的索引合并(index merge)策略,一定程度上可以使用多个单列索引定位</p>
</li>
<li><p>where查询条件的列最好使用多列索引而不是单独列单独索引</p>
</li>
</ol>
<h3 id="2-3-4-选择合适的索引顺序"><a href="#2-3-4-选择合适的索引顺序" class="headerlink" title="2.3.4 选择合适的索引顺序"></a>2.3.4 选择合适的索引顺序</h3><ol>
<li><p>将选择性最高的列放在索引最前列</p>
</li>
<li><p>性能不只依赖于所有索引列的选择性,也和查询条件的具体值分布有关,可能需要根据运行频率最高的查询调整索引列顺序</p>
</li>
<li><p>有时需要根据排序,分组和范围条件综合考虑</p>
</li>
</ol>
<h3 id="2-3-5-聚簇索引"><a href="#2-3-5-聚簇索引" class="headerlink" title="2.3.5 聚簇索引"></a>2.3.5 聚簇索引</h3><ol>
<li><p>聚簇索引并不是单独的索引类型,而是一种数据存储方式.叶子页包含行的全部数据,节点页只包含索引列</p>
</li>
<li><p>InnoDB默认使用主键聚集数据,如果没有会选择一个唯一的非空索引作为<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html" target="_blank" rel="noopener">聚簇索引</a></p>
</li>
<li><p>可以把相关数据保存一起,减少磁盘I/O</p>
</li>
<li><p>数据访问更快</p>
</li>
<li><p>插入速度严重依赖插入顺序</p>
</li>
<li><p>更新聚簇索引代价高</p>
</li>
<li><p>可能面临”页分裂”问题,导致占用更多磁盘空间</p>
</li>
<li><p>可能导致全表扫描变慢,由于行比较稀疏或页分裂导致数据存储不连续</p>
</li>
<li><p>二级索引变大,二级索引访问需要两次索引查找</p>
</li>
</ol>
<h3 id="2-3-6-覆盖索引"><a href="#2-3-6-覆盖索引" class="headerlink" title="2.3.6 覆盖索引"></a>2.3.6 覆盖索引</h3><ol>
<li><p>如果一个索引包含所有需要查询的字段的值</p>
</li>
<li><p>覆盖索引必须要存储索引列的值</p>
</li>
<li><p>MySQL不能在索引中执行like 操作,但能在索引中做最左前缀匹配的like比较,因为可以转换为简单的比较操作</p>
</li>
<li><p>延迟关联: 先通过覆盖索引返回需要的主键再通过这些主键关联原表获得需要的行</p>
</li>
</ol>
<h3 id="2-3-7-使用索引扫描做排序"><a href="#2-3-7-使用索引扫描做排序" class="headerlink" title="2.3.7 使用索引扫描做排序"></a>2.3.7 使用索引扫描做排序</h3><ol>
<li><p>只有索引列的顺序和order by 子句的顺序一致时才能使用索引对结果做排序</p>
</li>
<li><p>如果关联多表,则只有当order by子句引用的字段全部为第一个表时才能使用索引排序</p>
</li>
</ol>
<h3 id="2-3-8-压缩索引"><a href="#2-3-8-压缩索引" class="headerlink" title="2.3.8 压缩索引"></a>2.3.8 压缩索引</h3><ol>
<li><p>MyISAM使用前缀压缩减少索引的大小</p>
</li>
<li><p>create table 时通过指定pack_keys控制压缩方式</p>
</li>
</ol>
<h3 id="2-3-9-未使用的索引"><a href="#2-3-9-未使用的索引" class="headerlink" title="2.3.9 未使用的索引"></a>2.3.9 未使用的索引</h3><ol>
<li><p>通过查询INFORMATION_SCHEMA.INDEX_STATISTICES能查到每个索引的使用频率</p>
</li>
<li><p>冗余和重复的索引会降低性能</p>
</li>
</ol>
<h3 id="2-3-10-索引和锁"><a href="#2-3-10-索引和锁" class="headerlink" title="2.3.10 索引和锁"></a>2.3.10 索引和锁</h3><ol>
<li>InnoDB在二级索引上使用共享(读)锁,但访问主键索引需要排他(写)锁,消除了使用覆盖索引的可能</li>
</ol>
<h2 id="2-4-维护索引和表"><a href="#2-4-维护索引和表" class="headerlink" title="2.4 维护索引和表"></a>2.4 维护索引和表</h2><ol>
<li><p>check table 通常能够找出大多数的表和索引的错误</p>
</li>
<li><p>MyISAM表易损坏,InnoDB不容易,损坏可能是硬件或人为错误</p>
</li>
<li><p>MySQL查询优化器通过两个api,一个获取范围大概数据量,一个返回各种类型的数据包括索引基数</p>
</li>
<li><p>减少索引和数据的碎片,B-TREE索引可能碎片化,这会降低效率</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-3/" data-id="cjsa69dow000nr3zlj4uj89mg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-2/" class="article-date">
  <time datetime="2018-06-30T05:52:39.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《高性能MySQL》阅读笔记/">《高性能MySQL》阅读笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-2/">《高性能MySQL》阅读笔记二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-基准测试"><a href="#1-基准测试" class="headerlink" title="1. 基准测试"></a>1. 基准测试</h3><h4 id="1-1-应用"><a href="#1-1-应用" class="headerlink" title="1.1 应用"></a>1.1 应用</h4><p>验证系统的一些假设</p>
<p>重现系统异常</p>
<p>测试系统当前的运行情况</p>
<p>模拟更高的负载</p>
<p>规划业务增长</p>
<p>测试应用适应可变环境的能力</p>
<p>测试不同硬件,软件和操作系统的配置</p>
<h4 id="1-2-策略"><a href="#1-2-策略" class="headerlink" title="1.2 策略"></a>1.2 策略</h4><p>针对整个系统的整体测试, 集成式</p>
<p>单独测试MySQL, 单组件式</p>
<h4 id="1-3-测试指标"><a href="#1-3-测试指标" class="headerlink" title="1.3 测试指标"></a>1.3 测试指标</h4><ol>
<li><p>吞吐量: 在线事务处理(OLTP),单位为每秒事务数TPS</p>
</li>
<li><p>响应时间或延迟: 百分比响应时间较为代表性</p>
</li>
<li><p>并发性: 任意时间有多少同时发生的并发请求. 关注的是正在工作中的并发操作; 通常是为了测试应用在不同并发下的性能(吞吐量和响应时间)</p>
</li>
<li><p>可扩展性</p>
</li>
</ol>
<h4 id="1-4-方法"><a href="#1-4-方法" class="headerlink" title="1.4 方法"></a>1.4 方法</h4><p>避免常见错误</p>
<p>设计和规划基准测试</p>
<p>基准测试的运行时间设置</p>
<p>获取系统的性能和状态</p>
<p>收集分析绘图</p>
<h4 id="1-5-工具"><a href="#1-5-工具" class="headerlink" title="1.5 工具"></a>1.5 工具</h4><p>集成式测试工具</p>
<ol>
<li><p>ab: Apache http服务器基准测试工具,测试服务器qps, 针对单个url进行尽可能快的压力测试</p>
</li>
<li><p>http_load: 对Web服务器,可以通过输入文件对多个url进行随机测试</p>
</li>
<li><p>JMeter: 测试Web应用和其他入FTP服务器或通过JDBC进行数据库查询测试</p>
</li>
</ol>
<p>单组件式测试工具</p>
<ol>
<li><p>mysqlslap: 模拟服务器负载并输出计时信息</p>
</li>
<li><p>sqlbench: 测试服务器执行查询的速度</p>
</li>
<li><p>super smack: mysql 和postgresql的基准测试工具</p>
</li>
<li><p>database test suite</p>
</li>
<li><p>sysbench: 多线程系统压测工具, 支持mysql,操作系统,和硬件测试</p>
</li>
</ol>
<h3 id="2-服务器性能剖析"><a href="#2-服务器性能剖析" class="headerlink" title="2. 服务器性能剖析"></a>2. 服务器性能剖析</h3><h4 id="2-1-原则"><a href="#2-1-原则" class="headerlink" title="2.1 原则"></a>2.1 原则</h4><ol>
<li><p>性能即响应时间无法;</p>
</li>
<li><p>无法测量就无法有效优化</p>
</li>
</ol>
<h4 id="2-2-书中推荐工具"><a href="#2-2-书中推荐工具" class="headerlink" title="2.2 书中推荐工具"></a>2.2 书中推荐工具</h4><ol>
<li><p>New Relic: 收集分析数据,提供web界面</p>
</li>
<li><p>xhprof: Facebook开源的轻量级PHP性能分析工具</p>
</li>
<li><p>Percona Toolkit: pt-query-digest 生成慢查询日志分析报告</p>
</li>
</ol>
<h4 id="2-3-剖析查询"><a href="#2-3-剖析查询" class="headerlink" title="2.3 剖析查询"></a>2.3 剖析查询</h4><ol>
<li><p>SHOW PROFILE: 将profiling开启后,执行的sql的剖析信息会被记录到临时表, 通过 show profile from query (index)命令即可以获取到执行的过程信息</p>
</li>
<li><p>SHOW STATUS: 非剖析工具,主要用在对于执行完后观察某些计数器的值</p>
</li>
<li><p>使用慢查询日志</p>
</li>
</ol>
<h4 id="2-4-诊断间歇性问题"><a href="#2-4-诊断间歇性问题" class="headerlink" title="2.4 诊断间歇性问题"></a>2.4 诊断间歇性问题</h4><ol>
<li><p>show global status: 通过某些计数器的”尖刺”或”凹陷”分析问题</p>
</li>
<li><p>show processlist: 观察是否有大量线程处于不正常的状态或其他不正常特征</p>
</li>
<li><p>使用innotop: 实时地展示服务器正在发生的事情，监控innodb,监控多个MySQL实例</p>
</li>
<li><p>使用慢查询日志</p>
</li>
</ol>
<h4 id="2-5-其他剖析工具"><a href="#2-5-其他剖析工具" class="headerlink" title="2.5 其他剖析工具"></a>2.5 其他剖析工具</h4><ol>
<li><p>自带的一些INFORMATION_SCHEMA统计表</p>
</li>
<li><p>使用strace工具,pt-iopfofile工具生成I/O活动报告</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-2/" data-id="cjsa69dny0005r3zl10wng1t7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-1/" class="article-date">
  <time datetime="2018-06-30T03:21:11.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《高性能MySQL》阅读笔记/">《高性能MySQL》阅读笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-1/">《高性能MySQL》阅读笔记一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-MySQL服务器逻辑架构"><a href="#1-MySQL服务器逻辑架构" class="headerlink" title="1. MySQL服务器逻辑架构"></a>1. MySQL服务器逻辑架构</h1><p>连接/线程处理: 基于C/S的工具类似,实现连接处理,授权认证,安全等.</p>
<p>查询缓存/解析器: 实现查询解析,分析,优化,缓存.内置函数和跨存储引擎如存储过程,触发器,视图等.</p>
<p>存储引擎: 数据的存储和提取.不会解析sql,独立与上层服务器通过api进行通信.</p>
<h1 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2. 并发控制"></a>2. 并发控制</h1><p>每种存储引擎有不同的锁策略和锁粒度</p>
<p>表锁是MySQL中最基本,开销最小的策略,阻塞其他用户对该表的读写操作.写锁比读锁有更高的优先级.</p>
<p>行级锁: InnoDB和[XtraDB][1],行级锁只在存储引擎实现</p>
<p>事务: ACID, 原子性,一致性,隔离性(isolation),持久性(durability).</p>
<p>MySQL默认的[事务隔离级别][2]为可重复读(REPEATABLE READ)</p>
<p>死锁: 不同引擎处理方式不同.InnoDB 处理死锁方法,将持有最少行级排他锁的事务进行回滚</p>
<p>多版本并发控制(MVCC): 如InnoDB, 通过在每行记录后面保存两个列存储创建和删除时的系统版本号.</p>
<h1 id="3-存储引擎"><a href="#3-存储引擎" class="headerlink" title="3. 存储引擎"></a>3. 存储引擎</h1><p>创建表时,MySQL会在数据库子目录下创建一个同名.frm文件保存表的定义</p>
<p>InnoDB: 处理大量的短期事务, 通过间隙锁锁定查询涉及的行和索引中的间隙进行锁定,防止幻影行的插入, 基于聚簇索引创建表.通过一些机制和工具支持真正的热备份.**一般优先考虑InnoDB存储引擎**</p>
<p>MyISAM: 包括全文索引,压缩,空间函数,延迟更新索引键等特性,不支持事务和行级锁,崩溃后无法安全恢复.对于只读数据,表小可以忍受修复操作可以使用该引擎.</p>
<p>如果要使用全文索引,建议用InnoDB加上Sphinx组合替换MyISAM</p>
<p>使用引擎考虑:事务,备份,崩溃恢复,特有特性</p>
<p>日志型应用: MyISAM 或者Archive,因为开销低插入速度快更为适合</p>
<p>对于大数据量需要建立数据仓库,[Infobright][3]和[TokuDB][4]是比较好的解决方案</p>
<p>[1]: <a href="https://mariadb.com/kb/zh-cn/about-xtradb/" target="_blank" rel="noopener">https://mariadb.com/kb/zh-cn/about-xtradb/</a></p>
<p>[2]: <a href="https://zh.wikipedia.org/wiki/事務隔離" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/事務隔離</a></p>
<p>[3]: <a href="http://www.csdn.net/article/2014-08-26/2821379" target="_blank" rel="noopener">http://www.csdn.net/article/2014-08-26/2821379</a></p>
<p>[4]: <a href="http://blog.jobbole.com/109104/" target="_blank" rel="noopener">http://blog.jobbole.com/109104/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-1/" data-id="cjsa69dnx0004r3zln9pm0j64" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/18/http-1/" class="article-date">
  <time datetime="2018-06-18T03:21:11.000Z" itemprop="datePublished">2018-06-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《HTTP权威指南》阅读笔记/">《HTTP权威指南》阅读笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/18/http-1/">《HTTP权威指南》阅读笔记一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-常见概念"><a href="#1-常见概念" class="headerlink" title="1. 常见概念"></a>1. 常见概念</h1><ol>
<li><p>MIME：Multipurpose Internet Mail Extension，电子邮件系统和HTTP用于描述标记多媒体内容</p>
</li>
<li><p>URI：统一资源标识符，可以有URL和URN两种形式</p>
</li>
<li><p>URL：协议+服务器地址+资源路径</p>
</li>
<li><p>事务：通过HTTP报文格式化数据块完成一次请求和响应</p>
</li>
</ol>
<h1 id="2-URL与资源"><a href="#2-URL与资源" class="headerlink" title="2. URL与资源"></a>2. URL与资源</h1><ol>
<li><p>大多数URL方案的语法建立在<scheme>://<user>:<password>@<host>:<port>/<path></path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></p>
</li>
<li><p>设计URL使其可以通过任意因特网协议安全传输是很重要的，有些协议如SMTP的传输方法只能使用相对较小，通用的安全字母表中的字符</p>
</li>
<li><p>URL中包含如中文等非安全字母表二进制数据或字符时，则需要进行转义</p>
</li>
<li><p>转义：百分号+字符编码的十六进制数</p>
</li>
</ol>
<h1 id="3-HTTP报文"><a href="#3-HTTP报文" class="headerlink" title="3. HTTP报文"></a>3. HTTP报文</h1><ol>
<li>组成：对报文进行描述的起始行start line \r\n作为行结束，包含属性的首部块header，包含数据的body</li>
</ol>
<h2 id="常见HTTP方法"><a href="#常见HTTP方法" class="headerlink" title="常见HTTP方法"></a>常见HTTP方法</h2><ol>
<li>GET，HEAD，POST，PUT，DELETE，TRACE(对可能经过代理服务器传送的报文进行追踪，服务响应会带上实际收到的请求原文)，OPTIONS(决定可以在服务器上执行哪些方法)</li>
</ol>
<h2 id="已定义状态码"><a href="#已定义状态码" class="headerlink" title="已定义状态码"></a>已定义状态码</h2><ol>
<li>100-101：信息提示</li>
<li>200-206：成功</li>
<li>300-305：重定向</li>
<li>400-415：客户端错误</li>
<li>500-505：服务端错误</li>
</ol>
<h1 id="4-连接管理"><a href="#4-连接管理" class="headerlink" title="4. 连接管理"></a>4. 连接管理</h1><ol>
<li>连接过程：解析主机名，dns查询ip，获取端口号，发起连接，发送请求报文，返回响应报文，关闭连接</li>
<li>HTTP事务时延：DNS查询，连接，请求，处理，响应，关闭</li>
<li>性能聚焦区域：TCP连接，TCP慢启动拥塞控制，数据聚集的Nagle算法+TCP延迟确认，TIME_WAIT时延和端口耗尽</li>
<li>并行连接：由客户端的网络带宽限制并行连接数</li>
<li>持久连接：HTTP/1.1及HTTP/1.0的增强版本 允许设备在事务处理结束时将连接保持打开状态，省去建立连接和慢启动的阶段，1.0可以通过Connection：keep-alive</li>
<li>管道化连接：HTTP/1.1允许在持久连接上使用请求管道，响应到达前将请求放入队列，不能传送非幂等请求如POST</li>
</ol>
<h1 id="5-Web服务器"><a href="#5-Web服务器" class="headerlink" title="5. Web服务器"></a>5. Web服务器</h1><ol>
<li>重定向使用场景：永久删除或临时删除的资源，负载均衡，服务器关联，规范目录名称</li>
<li>对非持久连接，发送完响应关闭服务端连接；对持久连接，需要正确计算content-length首部</li>
</ol>
<h1 id="6-代理"><a href="#6-代理" class="headerlink" title="6. 代理"></a>6. 代理</h1><ol>
<li>代理可以监视流量并对其进行修改</li>
<li>应用场景：安全防火墙，Web缓存，反向代理，内容路由器，转码，匿名</li>
<li>via： 列出了与报文途径的每个中间节点</li>
</ol>
<h1 id="7-缓存"><a href="#7-缓存" class="headerlink" title="7. 缓存"></a>7. 缓存</h1><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ol>
<li>冗余的数据传输：服务器多次传输同一份文档，增大负担，消耗带宽</li>
<li>带宽瓶颈：客户端会以路径上最慢的网速访问服务器，如果客户端能在局域网获取一份副本，将大大提升性能</li>
<li>瞬间拥塞：使web服务器过载</li>
<li>距离时延</li>
</ol>
<h2 id="缓存再验证"><a href="#缓存再验证" class="headerlink" title="缓存再验证"></a>缓存再验证</h2><ol>
<li>大部分缓存只有在客户端发起请求，且副本时间需要再次检测才会进行再验证</li>
<li>向原始服务器发送小请求，如果返回304，则缓存继续有效</li>
<li>首部：if-modified-since，只有在缓存了对象的副本后又对其进行修改，才发送此对象</li>
<li>商业代理缓存会在via首部附加额外信息以描述命中情况</li>
</ol>
<h2 id="HTTP缓存体系"><a href="#HTTP缓存体系" class="headerlink" title="HTTP缓存体系"></a>HTTP缓存体系</h2><ol>
<li>缓存存储策略：决定http响应内容是否可缓存到客户端，Cache-Control</li>
<li>缓存过期策略：决定客户端是否可以直接使用缓存数据，Expires</li>
<li>缓存对比策略：将缓存在客户端的数据标识发往服务端，服务端会查看if-modified-since等请求头，对比判断标识是否有效，如果有效则返回304</li>
</ol>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ol>
<li><a href="https://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="noopener">HTTP缓存控制小结</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24467558" target="_blank" rel="noopener">彻底弄懂 Http 缓存机制</a></li>
</ol>
<h1 id="8-网关，隧道及中继"><a href="#8-网关，隧道及中继" class="headerlink" title="8. 网关，隧道及中继"></a>8. 网关，隧道及中继</h1><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>如应用程序服务器，早期的CGI通用网关接口</p>
<h2 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h2><ol>
<li>web隧道允许用户通过http连接发送非http流量</li>
<li>使用http方法CONNECT建立http隧道</li>
<li>SSL隧道：最初的web隧道是为了通过防火墙传输SSL流量。发送CONNECT请求，返回认证请求，发送带有认证信息CONNECT请求，建立连接</li>
</ol>
<h2 id="中继"><a href="#中继" class="headerlink" title="中继"></a>中继</h2><ol>
<li>盲转发</li>
<li>无法处理Connection：keep-alive</li>
</ol>
<h1 id="9-爬虫"><a href="#9-爬虫" class="headerlink" title="9. 爬虫"></a>9. 爬虫</h1><ol>
<li>链接提取及相对链接的标准化</li>
<li>避免环路的出现</li>
<li>广度优先</li>
<li>节流</li>
<li>内容指纹</li>
</ol>
<h1 id="10-客户端识别与cookie机制"><a href="#10-客户端识别与cookie机制" class="headerlink" title="10. 客户端识别与cookie机制"></a>10. 客户端识别与cookie机制</h1><h2 id="用户识别机制"><a href="#用户识别机制" class="headerlink" title="用户识别机制"></a>用户识别机制</h2><ol>
<li>承载用户信息的HTTP首部：user-agent，cookie，referer，x-forward–for等</li>
<li>客户端IP地址：并不能精确识别客户</li>
<li>用户登录：通过www-authenticate，authorization首部</li>
<li>cookie</li>
</ol>
<h1 id="11-基本认证机制"><a href="#11-基本认证机制" class="headerlink" title="11. 基本认证机制"></a>11. 基本认证机制</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/18/http-1/" data-id="cjsa69dns0002r3zlu6gzme67" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx文档笔记/">Nginx文档笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python源码学习/">Python源码学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis文档阅读笔记/">Redis文档阅读笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《HTTP权威指南》阅读笔记/">《HTTP权威指南》阅读笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《高性能MySQL》阅读笔记/">《高性能MySQL》阅读笔记</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/17/amqp/">Python amqp源码学习</a>
          </li>
        
          <li>
            <a href="/2018/06/30/redis-2/">Redis文档阅读笔记二</a>
          </li>
        
          <li>
            <a href="/2018/06/30/redis-1/">Redis文档阅读笔记一</a>
          </li>
        
          <li>
            <a href="/2018/06/30/mysql-6/">《高性能MySQL》阅读笔记六</a>
          </li>
        
          <li>
            <a href="/2018/06/30/mysql-5/">《高性能MySQL》阅读笔记五</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Whales<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>