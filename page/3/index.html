<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>沧海一粟</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="沧海一粟">
<meta property="og:url" content="https://whales2018.github.io/page/3/index.html">
<meta property="og:site_name" content="沧海一粟">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="沧海一粟">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">沧海一粟</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://whales2018.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-mysql-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-5/" class="article-date">
  <time datetime="2018-06-30T06:15:53.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《高性能MySQL》阅读笔记/">《高性能MySQL》阅读笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-5/">《高性能MySQL》阅读笔记五</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-优化服务器设置"><a href="#1-优化服务器设置" class="headerlink" title="1. 优化服务器设置"></a>1. 优化服务器设置</h1><ol>
<li>MySQL有大量的可以修改的参数,但不应该随便修改.应该将更多时间花在schema的优化,索引,查询设计上</li>
<li>配置文件路径: 通常在/etc/my.cnf</li>
<li>不建议动态修改变量,因为可能导致意外的副作用</li>
<li>通过基准测试迭代优化</li>
<li>具体配置项设置请参照官网手册,这里只提及部分</li>
</ol>
<h2 id="1-1-配置内存使用"><a href="#1-1-配置内存使用" class="headerlink" title="1.1 配置内存使用"></a>1.1 配置内存使用</h2><ol>
<li>确定可使用内存上限</li>
<li>每个连接使用多少内存,如排序缓冲和临时表</li>
<li>确定操作系统内存使用量</li>
<li>把剩下的分配给缓存,如InnoDB缓存池</li>
</ol>
<h2 id="1-2-配置MySQL的I-O行为"><a href="#1-2-配置MySQL的I-O行为" class="headerlink" title="1.2 配置MySQL的I/O行为"></a>1.2 配置MySQL的I/O行为</h2><ol>
<li>有些配置项影响如何同步数据到磁盘及如何恢复操作,这对性能影响很大,而且表现了性能和数据安全之间的平衡<h3 id="1-2-1-InnoDB-I-O配置"><a href="#1-2-1-InnoDB-I-O配置" class="headerlink" title="1.2.1 InnoDB I/O配置"></a>1.2.1 InnoDB I/O配置</h3></li>
<li>重要配置: InnoDB日志文件大小,InnoDB怎样刷新日志缓冲,InnoDB怎样执行I/O</li>
<li>InnoDB使用日志减少提交事务时开销,不用每个事务提交时把缓冲池的脏块刷到磁盘中</li>
<li>事务日志可以把随机IO变成顺序IO,同时如果发生断电,InnoDB可以重放日志恢复已经提交的事务</li>
<li>sync_binlog选项控制MySQL怎么刷新二进制日志到磁盘</li>
<li>把二进制日志放到一个带有电池保护的写缓存的RAID卷可以极大的提升性能</li>
</ol>
<h3 id="1-2-2-MyISAM的I-O配置"><a href="#1-2-2-MyISAM的I-O配置" class="headerlink" title="1.2.2 MyISAM的I/O配置"></a>1.2.2 MyISAM的I/O配置</h3><ol>
<li>因为MyISAM表每次写入都会将索引变更刷新到磁盘</li>
<li>批量操作时,通过设置delay_key_write可以延迟索引写入,可以提升性能</li>
<li>配置MyISAM怎样尝试从损坏中恢复</li>
</ol>
<h2 id="1-3-配置MySQL并发"><a href="#1-3-配置MySQL并发" class="headerlink" title="1.3 配置MySQL并发"></a>1.3 配置MySQL并发</h2><h3 id="1-3-1-InnoDB并发配置"><a href="#1-3-1-InnoDB并发配置" class="headerlink" title="1.3.1 InnoDB并发配置"></a>1.3.1 InnoDB并发配置</h3><ol>
<li>如果在InnoDB并发方面有问题,解决方案通常是升级服务器</li>
<li>innodb_thread_concurrency: 限制一次性可以有多少线程进入内核(根据实践取合适值)</li>
<li>innodb_thread_sleep_delay: 线程第一次进入内核失败等的时间,如果还不能进入则放入等待线程队列</li>
<li>innodb_commit_concurrency: 控制有多少线程可以在同一时间提交</li>
<li>使用线程池限制并发: MariaDB已经实现</li>
</ol>
<h3 id="1-3-2-MyISAM并发配置"><a href="#1-3-2-MyISAM并发配置" class="headerlink" title="1.3.2 MyISAM并发配置"></a>1.3.2 MyISAM并发配置</h3><ol>
<li>concurrency_insert: 配置MyISAM打开并发插入</li>
</ol>
<h2 id="1-4-其他"><a href="#1-4-其他" class="headerlink" title="1.4 其他"></a>1.4 其他</h2><ol>
<li>基于工作负载的配置: 利用工具分析并调整配置</li>
<li>max_connections: 保证服务器不会因应用程序激增的连接而不堪重负</li>
<li>安全和稳定的设置: 感兴趣者请自行google</li>
<li>高级InnoDB设置: 感兴趣者请自行google</li>
<li>InnoDB两个重要配置: innodb_buffer_pool_size和innodb_log_file_size</li>
</ol>
<h1 id="2-复制"><a href="#2-复制" class="headerlink" title="2. 复制"></a>2. 复制</h1><p>MySQL内建的复制功能是构建基于MySQL的大规模,高性能应用的基础.同时也是高可用性,可扩展性,灾难恢复,备份及数据仓库等工作的基础</p>
<h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>解决问题: 让一台服务器的数据与其他服务器保持同步.主库可以同步到多台备库,备库本身也可以配置为另一台服务器的主库</li>
<li>复制原理: 通过在主库上记录二进制日志,在备库重放日志的方式实现异步的数据复制</li>
<li>复制方式: 基于行的复制和基于语句的复制</li>
<li>向后兼容: 新版本只能作为老版本的备库,反之不行</li>
</ol>
<h2 id="2-2-用途"><a href="#2-2-用途" class="headerlink" title="2.2 用途"></a>2.2 用途</h2><ol>
<li>数据分布: 在不同地理位置分布数据备份,可以随意停止或开始复制.基于行比基于语句带宽压力更大</li>
<li>负载均衡: 将读操作分布到多个服务器上</li>
<li>备份: 复制是备份的一项有意义的技术补充</li>
<li>高可用性和故障切换: 避免单点失败</li>
<li>MySQL升级测试: 一种普遍做法是使用一个更高版本的MySQL作为备库保证实例升级前查询能够在备库按照预期执行</li>
</ol>
<h2 id="2-3-过程"><a href="#2-3-过程" class="headerlink" title="2.3 过程"></a>2.3 过程</h2><ol>
<li>主库把数据更改记录到二进制日志(Binary Log)</li>
<li>备库将主库上的日志复制到自己的中继日志(Relay Log)</li>
<li>备库读取中继日志中的事件,将其重放到备库数据上</li>
<li>局限: 主库上并发运行的查询在备库只能串行化执行,因为只有一个sql线程重放中继日志事件,这是很多工作负载的性能瓶颈</li>
</ol>
<h2 id="2-4-复制配置"><a href="#2-4-复制配置" class="headerlink" title="2.4 复制配置"></a>2.4 复制配置</h2><ol>
<li>在每台服务器上创建复制账号: 需要REPLICATION SLAVE权限</li>
<li>配置主库和备库: 每个服务器的ID需要唯一不能冲突</li>
<li>通知备库连接到主库并从主库复制数据</li>
<li>CHANGE MASTER TO: 指定备库连接的主库设置</li>
<li>SHOW SLAVE STATUS: 检查复制是否正确执行</li>
<li>START SLAVE: 开始复制</li>
<li>SHOW PROCESSLIST: 查看复制线程,IO线程(发送或获取日志),SQL线程(重放日志)</li>
<li>推荐配置: 开启sync_binlog</li>
</ol>
<h2 id="2-5-从另一个服务器开始复制"><a href="#2-5-从另一个服务器开始复制" class="headerlink" title="2.5 从另一个服务器开始复制"></a>2.5 从另一个服务器开始复制</h2><p>问题: 主库已经运行一段时间,用一台新安装的备库与之同步<br>保持同步条件:</p>
<ol>
<li>某个时间点的主库的数据快照</li>
<li>主库当前的二进制日志文件,和获得数据快照时在该二进制日志文件中的偏移量.通过这两个可以确定二进制日志的位置</li>
<li>从快照时间到现在的二进制日志</li>
</ol>
<p>克隆备库方法:</p>
<ol>
<li>冷备份: 关闭主库,复制数据.主库重启后会使用新的二进制文件,在备库指向这个文件的起始处</li>
<li>热备份:如果只有MyISAM,可以通过mysqlhotcopy或rsync来复制数据</li>
<li>如果只包含InnoDB: 可以使用mysqldump转储主库数据并加载到备库,然后设置相应的二进制日志坐标</li>
<li>使用快照或备份: 使用主库的快照或者备份初始化备库,然后指定二进制日志坐标</li>
<li>使用Percona Xtrabackup: 备份时不阻塞服务器操作,可以在不影响主库情况下设置备库</li>
<li>使用另外的备库: 实质就是把另外的备库当成主库进行数据克隆</li>
</ol>
<h2 id="2-6-复制的原理"><a href="#2-6-复制的原理" class="headerlink" title="2.6 复制的原理"></a>2.6 复制的原理</h2><h3 id="2-6-1-基于语句的复制"><a href="#2-6-1-基于语句的复制" class="headerlink" title="2.6.1 基于语句的复制"></a>2.6.1 基于语句的复制</h3><ol>
<li>主库会记录那些造成数据更改的查询</li>
<li>MySQL5.0之前只支持基于语句的复制</li>
<li>对于函数,存储过程和触发器在基于语句的复制模式可能存在问题</li>
<li>更新必须是串行,需要更多的锁</li>
</ol>
<h3 id="2-6-2-基于行的复制"><a href="#2-6-2-基于行的复制" class="headerlink" title="2.6.2 基于行的复制"></a>2.6.2 基于行的复制</h3><ol>
<li>将实际的数据记录在二进制日志</li>
<li>能够更高效复制数据</li>
<li>基于行的复制事件格式,对人不可读,可以使用mysqlbinlog</li>
<li>很难进行时间点恢复</li>
<li>有些操作,如全表更新(update)复制开销会很大</li>
</ol>
<h2 id="2-7-复制拓扑"><a href="#2-7-复制拓扑" class="headerlink" title="2.7 复制拓扑"></a>2.7 复制拓扑</h2><h3 id="2-7-1-基本原则"><a href="#2-7-1-基本原则" class="headerlink" title="2.7.1 基本原则"></a>2.7.1 基本原则</h3><ol>
<li>一个MySQL备库实例只能有一个主库</li>
<li>每个备库必须有一个唯一的服务器id</li>
<li>一个主库可以有多个备库</li>
<li>如果打开log_slave_update一个备库可以把其主库上的数据变化传播到其他备库</li>
</ol>
<h3 id="2-7-2-一主多备"><a href="#2-7-2-一主多备" class="headerlink" title="2.7.2 一主多备"></a>2.7.2 一主多备</h3><ol>
<li>适用于少量写和大量读,可以把读分摊到多个备库上</li>
<li>当作待用的主库</li>
<li>放到远程数据中心,用作灾难恢复</li>
<li>作为备份,培训,开发或测试服务器</li>
</ol>
<h3 id="2-7-3-双主复制"><a href="#2-7-3-双主复制" class="headerlink" title="2.7.3 双主复制"></a>2.7.3 双主复制</h3><ol>
<li>个数据库互为主库和备库</li>
<li>容易造成数据不同步</li>
<li>通常并不建议使用这种模式</li>
</ol>
<h3 id="2-7-4-主动被动的双主模式"><a href="#2-7-4-主动被动的双主模式" class="headerlink" title="2.7.4 主动被动的双主模式"></a>2.7.4 主动被动的双主模式</h3><ol>
<li>类似双主复制,把其中一台配置为只读</li>
<li>类似于创建一个热备份</li>
<li>可以用作执行读操作,备份,离线维护及升级</li>
</ol>
<h3 id="2-7-5-有备库的双主模式"><a href="#2-7-5-有备库的双主模式" class="headerlink" title="2.7.5 有备库的双主模式"></a>2.7.5 有备库的双主模式</h3><ol>
<li>双主模式下,各自有备库</li>
</ol>
<h3 id="2-7-6-主库-分发主库和备库"><a href="#2-7-6-主库-分发主库和备库" class="headerlink" title="2.7.6 主库,分发主库和备库"></a>2.7.6 主库,分发主库和备库</h3><ol>
<li>问题: 备库足够多时会对主库造成很大的负载</li>
<li>方案: 将其中部分备库当成主库,分发给更多的备库</li>
<li>通过分发主库,可以对二进制日志事件执行过滤和重写规则</li>
</ol>
<h2 id="2-8-复制管理和维护"><a href="#2-8-复制管理和维护" class="headerlink" title="2.8 复制管理和维护"></a>2.8 复制管理和维护</h2><ol>
<li>监控复制: SHOW MASTER STATUS查看主库状态, SHOW BINLOG EVENTS查看复制事件</li>
<li>测量备库延迟: 可以使用Percona Toolkit里的pt-hearbeat</li>
<li>确定主备是否一致</li>
<li>备库换主库: 难点在于获取新主库合适的二进制日志位置</li>
<li>备库提升为主库分为计划内提升和计划外提升<h3 id="2-8-1-计划内提升"><a href="#2-8-1-计划内提升" class="headerlink" title="2.8.1 计划内提升"></a>2.8.1 计划内提升</h3></li>
<li>停止向老的主库写入</li>
<li>备库赶上主库</li>
<li>备库设置为主库</li>
<li>将备库和写操作指向新主库,然后开启主库的写入</li>
</ol>
<h3 id="2-8-2-计划外提升"><a href="#2-8-2-计划外提升" class="headerlink" title="2.8.2 计划外提升"></a>2.8.2 计划外提升</h3><p>当主库崩溃时,需要提升一台备库替代</p>
<ol>
<li>确定最新的备库</li>
<li>让所有备库执行完从崩溃前主库获得的中继日志,如果未完成则更换主库,会丢失原先的日志事件</li>
<li>重新完成主备的配置</li>
</ol>
<h2 id="2-9-复制的问题和解决方案"><a href="#2-9-复制的问题和解决方案" class="headerlink" title="2.9 复制的问题和解决方案"></a>2.9 复制的问题和解决方案</h2><h3 id="2-9-1-数据损坏或丢失"><a href="#2-9-1-数据损坏或丢失" class="headerlink" title="2.9.1 数据损坏或丢失"></a>2.9.1 数据损坏或丢失</h3><ol>
<li>主库意外关闭: 主库开启sync_binlog避免事件丢失,使用Percona Toolkit中的pt-table-checksum检查主备一致性</li>
<li>备库意外关闭: 重启后观察MySQL错误日志,想方法获取备库指向主库的日志偏移量</li>
<li>主库上的二进制日志损坏: 跳过所有损坏的事件,手动找到一个完好的事件开始</li>
<li>备库上的中继日志损坏: MySQL5.5后能在崩溃后自动重新获取中继日志</li>
<li>二进制日志于InnoDB事务日志不同步: 除非备库中继日志有保存,否则自求多福</li>
</ol>
<h3 id="2-9-2-其他"><a href="#2-9-2-其他" class="headerlink" title="2.9.2 其他"></a>2.9.2 其他</h3><ol>
<li>如果使用myisam,在关闭Mysql前需要确保已经运行了stop slave,否则在服务器关闭时会kill所有正在运行的查询. </li>
<li>如果是事务型,失败的更新会在主库上回滚而且不会记录到二进制日志</li>
<li>避免混用事务和非事务: 如果备库发生死锁而主库没有,事务型会回滚而非事务型则不会造成不同步</li>
<li>主库和备库使用不同存储引擎容易导致问题</li>
<li>不唯一和未定义备库服务器id</li>
<li>避免在主库上创建备库上没有的表,因为复制可能中断</li>
<li>基于语句复制时,主库上没有安全使用临时表的方法.丢失临时表: 备库崩溃时,任何复制线程拥有的临时表都会丢失,重启备库后所有依赖临时表的语句都会失败</li>
<li>InnoDB加锁读引起的锁争用: 将大命令拆成小命令可以有效减少锁竞争</li>
<li>过大的复制延迟: 定位执行慢的语句,改善机器配置</li>
<li>其他: 查看官网手册</li>
</ol>
<h2 id="2-10-复制高级特性"><a href="#2-10-复制高级特性" class="headerlink" title="2.10 复制高级特性"></a>2.10 复制高级特性</h2><ol>
<li>半同步复制: 当提交事务,客户端收到查询结束反馈前必须保证二进制日志已经传输到至少一台备库上,主库将事务提交到磁盘上之后会增加一些延迟</li>
<li>复制心跳: 保证备库一直与主库相联系,如果出现断开的网络连接,备库会注意到丢失的心跳数据</li>
</ol>
<h2 id="2-11-其他复制技术"><a href="#2-11-其他复制技术" class="headerlink" title="2.11 其他复制技术"></a>2.11 其他复制技术</h2><ol>
<li>Percona XtraDB Cluster的同步复制</li>
<li>Tungsten</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-5/" data-id="cjsvjedgp000xlwt9gh8w5d64" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-4/" class="article-date">
  <time datetime="2018-06-30T06:00:01.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《高性能MySQL》阅读笔记/">《高性能MySQL》阅读笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-4/">《高性能MySQL》阅读笔记四</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-查询性能优化"><a href="#1-查询性能优化" class="headerlink" title="1. 查询性能优化"></a>1. 查询性能优化</h1><h2 id="1-1-优化数据访问"><a href="#1-1-优化数据访问" class="headerlink" title="1.1 优化数据访问"></a>1.1 优化数据访问</h2><ol>
<li>检查是否检索大量超过需要的数据.是否访问太多行或太多列,增加网络开销,消耗cpu和内存资源</li>
<li>检查服务器层是否在分析大量超过需要的数据行</li>
</ol>
<h2 id="1-2-重构查询的方式"><a href="#1-2-重构查询的方式" class="headerlink" title="1.2 重构查询的方式"></a>1.2 重构查询的方式</h2><h3 id="1-2-1-切分查询"><a href="#1-2-1-切分查询" class="headerlink" title="1.2.1 切分查询"></a>1.2.1 切分查询</h3><ol>
<li>有时对于一个大查询我们需要分而治之,切分成小查询每次只完成一部分</li>
</ol>
<h3 id="1-2-2-分解关联查询"><a href="#1-2-2-分解关联查询" class="headerlink" title="1.2.2 分解关联查询"></a>1.2.2 分解关联查询</h3><ol>
<li>缓存效率更高: 方便缓存单表查询结果</li>
<li>执行单个查询可以减少锁的竞争</li>
<li>在应用层做关联，更容易对数据库进行拆分，更容易做到高性能和可扩展</li>
<li>使用in　代替关联查询可能比随机的关联要高效</li>
<li>可以减少冗余记录的查询</li>
</ol>
<h2 id="1-3-查询执行的基础"><a href="#1-3-查询执行的基础" class="headerlink" title="1.3 查询执行的基础"></a>1.3 查询执行的基础</h2><h3 id="1-3-1-查询流程"><a href="#1-3-1-查询流程" class="headerlink" title="1.3.1 查询流程"></a>1.3.1 查询流程</h3><ol>
<li>先检查缓存</li>
<li>sql解析,预处理,优化器生成相应的执行计划</li>
<li>调用存储引擎的api执行查询</li>
</ol>
<h3 id="1-3-2-通信协议"><a href="#1-3-2-通信协议" class="headerlink" title="1.3.2 通信协议"></a>1.3.2 通信协议</h3><ol>
<li>半双工,任何一时刻要么是服务器向客户端发送数据,要么是客户端向服务端发送数据</li>
<li>客户端从服务器获取数据时,实际是MySQL向客户端推送数据的过程</li>
</ol>
<h3 id="1-3-3-查询状态"><a href="#1-3-3-查询状态" class="headerlink" title="1.3.3 查询状态"></a>1.3.3 查询状态</h3><ol>
<li>Ｓleep: 线程正在等待客户端发送新的请求</li>
<li>Query: 线程正在执行查询或者正在将结果发送给客户端</li>
<li>Locked: 服务器层,线程正在等待表锁</li>
<li>Analyzing and statistics: 线程正在收集存储引擎统计信息,并生成查询的执行计划</li>
<li>Copying to tmp table: 线程正在执行查询,并且将结果集复制到一个临时表中.常见group by或文件排序操作</li>
<li>Sorting result: 线程正在对结果进行排序</li>
<li>Sending data: 线程可能在多个状态之间传送数据或在生成结果集或向客户端返回数据</li>
</ol>
<h3 id="1-3-4-查询优化"><a href="#1-3-4-查询优化" class="headerlink" title="1.3.4 查询优化"></a>1.3.4 查询优化</h3><h4 id="1-3-4-1-语法解析器和预处理"><a href="#1-3-4-1-语法解析器和预处理" class="headerlink" title="1.3.4.1 语法解析器和预处理"></a>1.3.4.1 语法解析器和预处理</h4><ol>
<li>通过关键字将sql语句进行解析,生成对应的解析树</li>
<li>解析器使用语法规则验证和解析查询</li>
<li>预处理器进一步检查解析树是否合法,验证权限</li>
</ol>
<h4 id="1-3-4-2-查询优化器"><a href="#1-3-4-2-查询优化器" class="headerlink" title="1.3.4.2 查询优化器"></a>1.3.4.2 查询优化器</h4><ol>
<li>一条查询可以有多种执行方式,优化器找到其中最好的执行计划,MySQL使用基于成本的优化器</li>
<li>优化类型</li>
<li>重新定义关联表的顺序</li>
<li>外联结转化成内连接</li>
<li>使用等价变换规则</li>
<li>优化count, min, max函数</li>
<li>预估并转化为常数表达式</li>
<li>覆盖索引扫描</li>
<li>子查询优化</li>
<li>提前终止查询,如limit</li>
<li>等值传播</li>
<li>In优化</li>
</ol>
<h4 id="1-3-4-3-关联查询"><a href="#1-3-4-3-关联查询" class="headerlink" title="1.3.4.3 关联查询"></a>1.3.4.3 关联查询</h4><ol>
<li>嵌套循环: 先在一个表中循环取出单条数据,然后再嵌套循环到下一个表中寻找匹配的行,如果最后一个联表无法找到更多的行,则返回上一层次关联表</li>
<li>UNION查询和子查询时都会将临时结果存放到一个临时表中</li>
</ol>
<h4 id="1-3-4-4-执行计划"><a href="#1-3-4-4-执行计划" class="headerlink" title="1.3.4.4 执行计划"></a>1.3.4.4 执行计划</h4><ol>
<li>MySQL生成一棵指令树,通过存储引擎执行完成并返回结果</li>
</ol>
<h4 id="1-3-4-5-排序优化"><a href="#1-3-4-5-排序优化" class="headerlink" title="1.3.4.5 排序优化"></a>1.3.4.5 排序优化</h4><ol>
<li>排序是一个成本很高的操作</li>
<li>MySQL排序: 如果数据量小,则在内存中进行; 数据量大则先分块再排序再合并</li>
<li>MySQL4.1后使用单次传输排序: 先读取查询所需要的所有列,再根据给定列排序</li>
</ol>
<h4 id="1-3-4-6-查询执行引擎"><a href="#1-3-4-6-查询执行引擎" class="headerlink" title="1.3.4.6 查询执行引擎"></a>1.3.4.6 查询执行引擎</h4><ol>
<li>根据执行计划的指令逐步执行</li>
</ol>
<h4 id="1-3-4-7-返回结果给客户端"><a href="#1-3-4-7-返回结果给客户端" class="headerlink" title="1.3.4.7 返回结果给客户端"></a>1.3.4.7 返回结果给客户端</h4><ol>
<li>如果查询可以缓存,则缓存在这个阶段进行</li>
<li>返回结果的过程是一个增量逐步返回的过程,一旦开始生成第一条结果时就可以开始向客户端返回结果集</li>
</ol>
<h2 id="1-4-查询优化器的局限"><a href="#1-4-查询优化器的局限" class="headerlink" title="1.4 查询优化器的局限"></a>1.4 查询优化器的局限</h2><ol>
<li>子查询相对糟糕(不是绝对),如子查询用in</li>
<li>联表查询与子查询根据场景不同有不同优势</li>
<li>MySQL无法将限制条件下推到子查询</li>
<li>索引合并优化</li>
<li>MySQL无法利用多核特性并行执行查询</li>
<li>MySQL并不支持哈希关联, MariaDB已经实现了真正的哈希关联  </li>
<li>松散索引扫描,无法按照不连续的方式扫描一个索引</li>
<li>最大值最小值函数的优化一般</li>
<li>不允许同一张表上同时查询和更新, 如update set 等于 select 自己.解决方法,可以通过关联临时表</li>
</ol>
<h2 id="1-5-查询优化器的提示"><a href="#1-5-查询优化器的提示" class="headerlink" title="1.5 查询优化器的提示"></a>1.5 查询优化器的提示</h2><ol>
<li>设置查询优化器参数,可以阅读官方手册</li>
<li>一般除非需要,修改查询优化器参数会提高维护成本</li>
</ol>
<h2 id="1-6-优化特定类型的查询"><a href="#1-6-优化特定类型的查询" class="headerlink" title="1.6 优化特定类型的查询"></a>1.6 优化特定类型的查询</h2><ol>
<li>关联查询: on的列加索引; 使用group by和order by 只使用一个表的列可以利用索引</li>
<li>优化LIMIT分页: 尽量使用覆盖索引</li>
<li>子查询: 尽量使用关联查询替换</li>
<li>静态查询分析: Percona Toolkit中的pt-query-advisor能解析查询日志,分析查询模式</li>
<li>使用用户自定义变量: 无法使用查询缓存,可能被优化器优化掉</li>
</ol>
<h1 id="2-MySQL高级特性"><a href="#2-MySQL高级特性" class="headerlink" title="2. MySQL高级特性"></a>2. MySQL高级特性</h1><h2 id="2-1-分区表"><a href="#2-1-分区表" class="headerlink" title="2.1 分区表"></a>2.1 分区表</h2><h3 id="2-1-1-应用"><a href="#2-1-1-应用" class="headerlink" title="2.1.1 应用"></a>2.1.1 应用</h3><ol>
<li>表非常大无法全部放在内存中,或者只在表的最后部分有热点数据其他均是历史数据</li>
<li>分区表的数据更容易维护</li>
<li>分区表的数据可以分布在不同的物理设备上</li>
<li>使用分区表避免某些瓶颈,如InnoDB单个索引的互斥访问</li>
<li>备份和恢复独立分区,对于大数据集效果较好</li>
</ol>
<h3 id="2-1-2限制"><a href="#2-1-2限制" class="headerlink" title="2.1.2限制"></a>2.1.2限制</h3><ol>
<li>一个表最多1024个分区</li>
<li>分区表达式必须是整数或返回整数的表达式</li>
<li>如果分区字段有主键或唯一索引列,那么所有主键列和唯一索引都必须包含进来</li>
<li>分区表中无法使用外键约束</li>
</ol>
<h3 id="2-1-3-原理"><a href="#2-1-3-原理" class="headerlink" title="2.1.3 原理"></a>2.1.3 原理</h3><ol>
<li>分区表由多个相关的底层表实现,存储引擎管理它们跟管理普通表一样</li>
<li>select 查询: 分区层打开并锁住所有底层表,优化器判断是否过滤分区,在调用存储引擎api访问各个分区数据</li>
<li>insert: 分区层打开并锁住所有底层表,确定分区,写入</li>
<li>delete: 分区层打开并锁住所有底层表,确定数据所在分区,删除</li>
<li>update: 分区层打开并锁住所有底层表,确定分区,取出数据,更新,确定分区,写入</li>
<li>打开并锁住所有底层表: 如果存储引擎实现行级锁如InnoDB,则会在分区层释放表锁</li>
</ol>
<h3 id="2-1-4-分区表类型"><a href="#2-1-4-分区表类型" class="headerlink" title="2.1.4 分区表类型"></a>2.1.4 分区表类型</h3><ol>
<li>根据范围进行分区: 每个分区储存落在某个范围的记录</li>
<li>根据键值进行分区,减少InnoDB互斥量竞争</li>
<li>使用数学模函数进行分区,然后将数据轮询放入不同的分区,适用于只想保留几天的数据</li>
</ol>
<h3 id="2-1-5-使用"><a href="#2-1-5-使用" class="headerlink" title="2.1.5 使用"></a>2.1.5 使用</h3><ol>
<li>问题回顾:数据量很大时,除非是索引覆盖查询,否则数据库需要根据索引扫描回表查询,产生大量的随机IO,数据库响应时间很大</li>
<li>全量扫描数据不要索引,根据分区定位数据位置</li>
<li>索引数据,分离热点. 将热点数据单独放在一个分区</li>
<li>NULL值会使分区过滤无效: 分区表达式接收NULL值并将其放到第一个分区导致查询时多查分区.解决方法:创建第一个无用分区存放NULL值数据</li>
<li>分区列和索引列不匹配,查询无法进行分区过滤</li>
<li>选择分区成本高,插入大量数据时都需要扫描分区定义找到分区</li>
<li>打开并锁住所有底层表的成本可能很高</li>
<li>维护分区的成本很高,同alter一样创建临时表然后拷贝数据</li>
<li>所有分区都必须使用相同的存储引擎</li>
</ol>
<h3 id="2-1-6-查询优化"><a href="#2-1-6-查询优化" class="headerlink" title="2.1.6 查询优化"></a>2.1.6 查询优化</h3><ol>
<li>在where条件带入分区列</li>
<li>创建分区时可以使用表达式,但是查询时只能在使用分区列本身进行比较时才能过滤分区,而不能根据表达式的值过滤分区</li>
</ol>
<h2 id="2-2-视图"><a href="#2-2-视图" class="headerlink" title="2.2 视图"></a>2.2 视图</h2><p>视图本身是一个虚拟表,不存放任何数据,不能对视图创建触发器</p>
<h3 id="2-2-1-算法"><a href="#2-2-1-算法" class="headerlink" title="2.2.1 算法"></a>2.2.1 算法</h3><ol>
<li>合并算法: 将存放的视图sql和用户发起的查询sql合并后执行</li>
<li>临时表算法: 由存放的视图sql先创建临时表后根据用户的查询sql查询返回</li>
</ol>
<h3 id="2-2-2-可更新视图"><a href="#2-2-2-可更新视图" class="headerlink" title="2.2.2 可更新视图"></a>2.2.2 可更新视图</h3><ol>
<li>可以通过更新视图更新相关表, 所有临时表算法实现的视图都无法更新</li>
</ol>
<h3 id="2-2-3-视图对性能的影响"><a href="#2-2-3-视图对性能的影响" class="headerlink" title="2.2.3 视图对性能的影响"></a>2.2.3 视图对性能的影响</h3><ol>
<li>一般情况视图不能提升性能,在某些情况下可以帮助提升性能,需要做比较详细的测试</li>
<li>视图还可以实现基于列的权限控制不用真正创建列权限</li>
</ol>
<h3 id="2-2-4-视图的限制"><a href="#2-2-4-视图的限制" class="headerlink" title="2.2.4 视图的限制"></a>2.2.4 视图的限制</h3><ol>
<li>不保存视图定义的原始sql语句</li>
<li>查看视图创建的语句,可以通过使用视图的.frm文件的最后一行获取一些信息</li>
</ol>
<h2 id="2-3-外键约束"><a href="#2-3-外键约束" class="headerlink" title="2.3 外键约束"></a>2.3 外键约束</h2><ol>
<li>InnoDB强制外键使用索引</li>
<li>查询需要额外访问一些表,需要额外的锁容易导致一些死锁</li>
<li>如果使用外键做约束,通常在应用程序里实现会更好</li>
</ol>
<h2 id="2-4-内部存储代码"><a href="#2-4-内部存储代码" class="headerlink" title="2.4 内部存储代码"></a>2.4 内部存储代码</h2><h3 id="2-4-1-优点"><a href="#2-4-1-优点" class="headerlink" title="2.4.1 优点"></a>2.4.1 优点</h3><ol>
<li>离数据最近,节省带宽和网络延迟</li>
<li>帮助提升安全性,应用程序可以通过存储过程访问那些没有权限的表</li>
<li>服务器端可以缓存存储过程的执行计划</li>
<li>维护方便,便于分工</li>
</ol>
<h3 id="2-4-2-缺点"><a href="#2-4-2-缺点" class="headerlink" title="2.4.2 缺点"></a>2.4.2 缺点</h3><ol>
<li>调试困难,难以定位问题</li>
<li>存储代码效率相对差</li>
<li>增加维护复杂性,存储过程会给数据库服务器增加额外压力</li>
<li>存在安全隐患,没有什么选项可以控制存储程序的资源消耗,所以一个小错误可能直接把服务器拖死</li>
</ol>
<h3 id="2-4-3-存储过程和函数"><a href="#2-4-3-存储过程和函数" class="headerlink" title="2.4.3 存储过程和函数"></a>2.4.3 存储过程和函数</h3><ol>
<li>优化器无法评估存储函数的执行成本</li>
<li>每个连接都有独立的存储过程的执行计划缓存,多个连接调用同一个存储过程会浪费缓存空间反复缓存同样的执行计划</li>
</ol>
<h3 id="2-4-4-触发器"><a href="#2-4-4-触发器" class="headerlink" title="2.4.4 触发器"></a>2.4.4 触发器</h3><ol>
<li>每个表的每个事件只能一个</li>
<li>MySQL只支持基于行的触发,如果变更的数据集非常庞大的化效率会很低</li>
<li>触发器的问题很难排查</li>
<li>可能导致死锁和锁等待</li>
<li>实现一些约束,系统维护任务及更新反范式化数据的时候会比较有用</li>
</ol>
<h3 id="2-4-5-事件"><a href="#2-4-5-事件" class="headerlink" title="2.4.5 事件"></a>2.4.5 事件</h3><ol>
<li>类似Linux的定时任务</li>
</ol>
<h2 id="2-5-游标"><a href="#2-5-游标" class="headerlink" title="2.5 游标"></a>2.5 游标</h2><ol>
<li>MySQL在服务器端提供只读的,单向的游标</li>
<li>一个存储过程中可以有多个游标,也可以嵌套</li>
</ol>
<h2 id="2-6-绑定变量"><a href="#2-6-绑定变量" class="headerlink" title="2.6 绑定变量"></a>2.6 绑定变量</h2><ol>
<li>创建一个绑定变量sql时客户端向服务器发送了一个sql语句原型</li>
<li>服务器端解析并存储这个sql语句的部分执行计划返回客户端一个sql语句处理句柄</li>
<li>可以使用问号作为sql的占位,在使用sql接口执行时赋予变量值</li>
</ol>
<h2 id="2-7-插件"><a href="#2-7-插件" class="headerlink" title="2.7 插件"></a>2.7 插件</h2><ol>
<li>存储过程插件</li>
<li>后台插件: 如Percona Server中包含的Handler-Socket</li>
<li>INFORMATION_SCHEMA插件</li>
<li>全文解析插件: 可以对文档进行分词处理</li>
<li>审计插件: 可以用作记录事件日志</li>
<li>认证插件: 扩展认证功能</li>
</ol>
<h2 id="2-8-字符集和校对"><a href="#2-8-字符集和校对" class="headerlink" title="2.8 字符集和校对"></a>2.8 字符集和校对</h2><ol>
<li>字符集是指一种从二进制编码到某类字符符号的映射</li>
<li>校对是指一组用于某个字符集的排序规则<h3 id="2-8-1-创建对象时的默认设置"><a href="#2-8-1-创建对象时的默认设置" class="headerlink" title="2.8.1 创建对象时的默认设置"></a>2.8.1 创建对象时的默认设置</h3></li>
<li>服务器,数据库,表都有默认的字符集和校对规则,这是一个逐层继承的默认设置</li>
<li>创建数据库时根据character_set_server设置来设定默认字符集</li>
</ol>
<h3 id="2-8-2-服务器和客户端通信设置"><a href="#2-8-2-服务器和客户端通信设置" class="headerlink" title="2.8.2 服务器和客户端通信设置"></a>2.8.2 服务器和客户端通信设置</h3><ol>
<li>服务端总是假设客户端按照character_set_client设置的字符来传输数据和sql语句</li>
<li>服务器端收到sql语句后根据character_set_connection转换成字符串</li>
<li>服务器端返回数据时会将其转换为character_set_result</li>
</ol>
<h3 id="2-8-3-选择字符集和校对规则"><a href="#2-8-3-选择字符集和校对规则" class="headerlink" title="2.8.3 选择字符集和校对规则"></a>2.8.3 选择字符集和校对规则</h3><ol>
<li>极简原则: 先为服务器选择合理的字符集在根据实际情况让某些列选择合适的字符集</li>
</ol>
<h3 id="2-8-4-对查询的影响"><a href="#2-8-4-对查询的影响" class="headerlink" title="2.8.4 对查询的影响"></a>2.8.4 对查询的影响</h3><ol>
<li>不同字符集和校对规则之间的转换会带来额外的开销</li>
<li>排序查询要求的字符集与服务器数据的字符集相同时才能利用索引进行排序</li>
<li>当两个字符集不同列关联两个表时,MySQL会尝试转换其中一个列的字符集</li>
</ol>
<h2 id="2-9-全文索引"><a href="#2-9-全文索引" class="headerlink" title="2.9 全文索引"></a>2.9 全文索引</h2><ol>
<li>自然语言的全文索引: 相关度是基于匹配的关键词个数及关键词在文档中出现的次数,整个索引中出现次数越少的词语匹配的相关度越高</li>
<li>布尔全文索引: 只有MyISAM才能使用</li>
<li>平时没接触过,有兴趣者请自行google</li>
</ol>
<h2 id="2-10-分布式XA事务"><a href="#2-10-分布式XA事务" class="headerlink" title="2.10 分布式XA事务"></a>2.10 分布式XA事务</h2><ol>
<li>事务协调器保证所有事务参与者完成工作,通知所有事务提交</li>
<li>内部XA事务: 存储引擎提交的同时,需要将提交的信息写入二进制日志</li>
<li>外部XA事务: XA事务是一种在多个服务器之间同步数据的方法,如果由于不能使用MySQL本身的复制或者性能并不是瓶颈可以尝试使用</li>
</ol>
<h2 id="2-11-查询缓存"><a href="#2-11-查询缓存" class="headerlink" title="2.11 查询缓存"></a>2.11 查询缓存</h2><ol>
<li>查询缓存系统会跟踪查询中涉及的每个表,如果表发生变化则缓存数据失效</li>
<li>缓存存放在一个引用表中,通过一个哈希值引用,哈希值包括查询本身,查询数据库等信息</li>
<li>当sql语句和客户端发送过来的其他原始信息,任何字符上的不同都会导致缓存不命中</li>
<li>打开查询缓存对读和写都会带来额外的消耗</li>
<li>InnoDB事务修改表时,会将这个表对应的查询缓存都设置失效</li>
<li>查询缓存被发现是一个影响服务器扩展性的因素</li>
<li>如果缓存了大量的查询结果,那么失效操作可能会造成系统僵死.因为靠一个全局锁保护,所有该操作都要等锁</li>
<li>减少碎片, 选择合适的query_cache_min_res_unit可以减少内存浪费</li>
<li>对于写密集型的应用,直接禁用更好</li>
<li>高并发环境也不适合.只有明确缓存的好处才使用</li>
<li>查询缓存的替代方案: 客户端缓存</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-4/" data-id="cjsvjedgo000wlwt9gh4ac9l9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-3/" class="article-date">
  <time datetime="2018-06-30T05:53:23.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《高性能MySQL》阅读笔记/">《高性能MySQL》阅读笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-3/">《高性能MySQL》阅读笔记三</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-schema与数据类型优化"><a href="#1-schema与数据类型优化" class="headerlink" title="1. schema与数据类型优化"></a>1. schema与数据类型优化</h1><h2 id="1-1-数据类型选择"><a href="#1-1-数据类型选择" class="headerlink" title="1.1 数据类型选择"></a>1.1 数据类型选择</h2><p>更小: 选择不超过需求范围的最小类型</p>
<p>更简单</p>
<p>避免使用Null: 含有Null列会使索引,索引统计和值更为复杂</p>
<p>分配空间: 根据实际需要分配.使用内存临时表或操作时会比较糟糕</p>
<p>特殊类型:书中举例,ip地址应该用无符号整数存储,MySQL提供inet_aton, inet_ntoa方法转换</p>
<h2 id="1-2-schema-设计陷阱"><a href="#1-2-schema-设计陷阱" class="headerlink" title="1.2 schema 设计陷阱"></a>1.2 schema 设计陷阱</h2><ol>
<li><p>太多列,存储引擎api需要在服务器层和存储引擎层通过行缓冲格式拷贝数据,然后解码.转换代价依赖于列的数量</p>
</li>
<li><p>太多的关联,单个查询最好在12个表以内</p>
</li>
<li><p>最好不用枚举enum</p>
</li>
<li><p>可以使用其他”空值”替代Null</p>
</li>
</ol>
<h2 id="1-3-范式和反范式"><a href="#1-3-范式和反范式" class="headerlink" title="1.3 范式和反范式"></a>1.3 范式和反范式</h2><ol>
<li><p>范式化: 每个事实数据只出现一次</p>
</li>
<li><p>反范式化: 信息是冗余的</p>
</li>
<li><p>第一范式1NF: 关系中的每个属性都不可再分</p>
</li>
<li><p>第二范式2NF: 每个表中的非主属性完全依赖于码(例如主键, 可以唯一决定属性集合)</p>
</li>
<li><p>第三范式3NF: 消除非主属性之间的依赖关系，只保留非主属性与码的依赖关系</p>
</li>
<li><p>范式化优点: 更新操作更快,占用空间更小</p>
</li>
<li><p>范式化缺点: 表的关联查询更多</p>
</li>
<li><p>混用范式和反范式: 从父表冗余一些数据到子表有利于排序, 缓存衍生值减少子查询计算</p>
</li>
</ol>
<h2 id="1-4-缓存表和汇总表"><a href="#1-4-缓存表和汇总表" class="headerlink" title="1.4 缓存表和汇总表"></a>1.4 缓存表和汇总表</h2><p>业务上有时需要一张完全独立的汇总表或缓存表主要用于满足检索的需求</p>
<ol>
<li><p>Flexviews实现物化视图,可以增量重新计算物化视图的内容</p>
</li>
<li><p>计数器表: 如果需要在表中保存计数器,更新计数器时,会有全局的互斥锁.要获的高并发更新的性能,可以将计数器保存在多行,每次随机选择一个进行更新</p>
</li>
</ol>
<h2 id="1-5-修改表结构"><a href="#1-5-修改表结构" class="headerlink" title="1.5 修改表结构"></a>1.5 修改表结构</h2><ol>
<li><p>大部分的alter table操作将导致服务中断</p>
</li>
<li><p>所有的modify column 操作都将导致表重建</p>
</li>
<li><p>可以新建一个.frm文件为修改后的表结构,替换原来的.frm文件避免表重建</p>
</li>
</ol>
<h1 id="2-创建高性能的索引"><a href="#2-创建高性能的索引" class="headerlink" title="2. 创建高性能的索引"></a>2. 创建高性能的索引</h1><p>索引是存储引擎用于快速查找记录的数据结构</p>
<h2 id="2-1-索引基础"><a href="#2-1-索引基础" class="headerlink" title="2.1 索引基础"></a>2.1 索引基础</h2><p>MySQL中,存储引擎先在索引中找到对应值根据匹配的索引记录找到对应的数据行.索引在存储引擎层实现</p>
<h3 id="2-1-1-B-Tree索引"><a href="#2-1-1-B-Tree索引" class="headerlink" title="2.1.1 B-Tree索引"></a>2.1.1 B-Tree索引</h3><ol>
<li><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构. </p>
</li>
<li><p>InnoDB使用B+Tree, NDB集群存储引擎实际使用T-Tree. 索引对多个值的排序一句是根据表定义索引时列的顺序.</p>
</li>
<li><p>索引对如下类型的查询有效</p>
</li>
<li><p>全值匹配</p>
</li>
<li><p>匹配最左前缀,只使用索引第一列</p>
</li>
<li><p>匹配列前缀: 只匹配某一列值的开头部分</p>
</li>
<li><p>匹配范围值</p>
</li>
<li><p>精确匹配某一列并范围匹配另外一列</p>
</li>
<li><p>只访问索引的查询: 查询只需要访问索引无需访问数据行(覆盖扫描)</p>
</li>
<li><p>限制</p>
</li>
<li><p>如果不是按照索引的最左列开始,则无法使用索引</p>
</li>
<li><p>不能跳过索引中的列,即定义索引(a,b,c),则使用a,c查询条件时,只能使用索引第一列</p>
</li>
<li><p>如果查询中有某个列的范围查询,则右边所有的列都无法使用索引优化查找</p>
</li>
</ol>
<h3 id="2-1-2-哈希索引"><a href="#2-1-2-哈希索引" class="headerlink" title="2.1.2 哈希索引"></a>2.1.2 哈希索引</h3><ol>
<li><p>对于每一行数据,存储引擎会对索引列计算一个哈希码.索引包含哈希码和行指针</p>
</li>
<li><p>MySQL中只有Memory存储引擎支持</p>
</li>
<li><p>限制</p>
</li>
<li><p>不能使用索引中的值避免读取行</p>
</li>
<li><p>无法用于排序</p>
</li>
<li><p>不支持部分索引列匹配查找</p>
</li>
<li><p>不支持范围查询</p>
</li>
<li><p>出现哈希冲突时会扫表</p>
</li>
</ol>
<h3 id="2-1-3-伪哈希索引"><a href="#2-1-3-伪哈希索引" class="headerlink" title="2.1.3 伪哈希索引"></a>2.1.3 伪哈希索引</h3><ol>
<li><p>应用: 当存储引擎不支持哈希索引,在B-Tree基础上使用哈希值索引查找</p>
</li>
<li><p>场景: 需要存储大量的url并根据url进行搜索查找</p>
</li>
<li><p>问题: 如果使用B-Tree存储,内容很大</p>
</li>
<li><p>方案: 删除url列索引,新增一个被索引的url_crc列,使用CRC32做哈希.</p>
</li>
<li><p>sql: select id from t_url where url=”<a href="https://www.google.as/&quot;" target="_blank" rel="noopener">https://www.google.as/&quot;</a> and url_crc=CRC32(“<a href="https://www.google.as/&quot;" target="_blank" rel="noopener">https://www.google.as/&quot;</a>)</p>
</li>
<li><p>结果: MySQL优化器会使用选择性很高体积很小的基于url_crc索引完成查找</p>
</li>
<li><p>缺陷: 需要维护哈希值, crc32表大时会出现大量冲突</p>
</li>
<li><p>注意: 不要使用SHA1和MD5做哈希函数,因为计算出来的哈希值比较长; 必须在where子句中包含常量</p>
</li>
<li><p>插件: 移植自Percona Server的FNV64可以在MySQL中作为哈希函数使用</p>
</li>
</ol>
<h3 id="2-1-4-空间数据索引-R-Tree"><a href="#2-1-4-空间数据索引-R-Tree" class="headerlink" title="2.1.4 空间数据索引(R-Tree)"></a>2.1.4 空间数据索引(R-Tree)</h3><ol>
<li>MyISAM表支持空间索引,可以用作地理数据存储</li>
</ol>
<h3 id="2-1-5-全文索引"><a href="#2-1-5-全文索引" class="headerlink" title="2.1.5 全文索引"></a>2.1.5 全文索引</h3><ol>
<li>全文索引是一种特殊类型索引,查找文本中的关键词,后续讨论</li>
</ol>
<h3 id="2-1-6-其他"><a href="#2-1-6-其他" class="headerlink" title="2.1.6 其他"></a>2.1.6 其他</h3><ol>
<li><p>TokuDB 使用分形树索引, 对于InnoDB的讨论也适用于TokuDB</p>
</li>
<li><p>ScaleDB 使用Patricia tries</p>
</li>
<li><p>InfiniDB和Infobright使用一些特殊的数据结构优化某些特殊的查询</p>
</li>
</ol>
<h2 id="2-2索引的优点"><a href="#2-2索引的优点" class="headerlink" title="2.2索引的优点"></a>2.2索引的优点</h2><ol>
<li><p>减少扫描数据量</p>
</li>
<li><p>避免排序和临时表</p>
</li>
<li><p>将随机I/O变成顺序I/O</p>
</li>
<li><p>对于TB级别的数据,经常会使用块级别的数据技术来替代索引</p>
</li>
</ol>
<h2 id="2-3-高性能的索引策略"><a href="#2-3-高性能的索引策略" class="headerlink" title="2.3 高性能的索引策略"></a>2.3 高性能的索引策略</h2><h3 id="2-3-1-独立的列"><a href="#2-3-1-独立的列" class="headerlink" title="2.3.1 独立的列"></a>2.3.1 独立的列</h3><ol>
<li>索引列不能是表达式一部分或函数参数,否则不能使用索引</li>
</ol>
<h3 id="2-3-2-前缀索引"><a href="#2-3-2-前缀索引" class="headerlink" title="2.3.2 前缀索引"></a>2.3.2 前缀索引</h3><ol>
<li><p>场景: 需要索引很长的字符列,这会让索引变得大且慢</p>
</li>
<li><p>方案: 根据业务找到最适合的前缀长度,创建前缀索引</p>
</li>
<li><p>优点: 索引更小,更快</p>
</li>
<li><p>缺点: MySQL无法使用前缀索引order by 和group by,也无法使用前缀索引做覆盖扫描</p>
</li>
<li><p>常见: 用16进制唯一id存储session id,如果采用长度为8的前缀索引能显著提升性能</p>
</li>
</ol>
<h3 id="2-3-3-多列索引"><a href="#2-3-3-多列索引" class="headerlink" title="2.3.3 多列索引"></a>2.3.3 多列索引</h3><ol>
<li><p>MySQL的索引合并(index merge)策略,一定程度上可以使用多个单列索引定位</p>
</li>
<li><p>where查询条件的列最好使用多列索引而不是单独列单独索引</p>
</li>
</ol>
<h3 id="2-3-4-选择合适的索引顺序"><a href="#2-3-4-选择合适的索引顺序" class="headerlink" title="2.3.4 选择合适的索引顺序"></a>2.3.4 选择合适的索引顺序</h3><ol>
<li><p>将选择性最高的列放在索引最前列</p>
</li>
<li><p>性能不只依赖于所有索引列的选择性,也和查询条件的具体值分布有关,可能需要根据运行频率最高的查询调整索引列顺序</p>
</li>
<li><p>有时需要根据排序,分组和范围条件综合考虑</p>
</li>
</ol>
<h3 id="2-3-5-聚簇索引"><a href="#2-3-5-聚簇索引" class="headerlink" title="2.3.5 聚簇索引"></a>2.3.5 聚簇索引</h3><ol>
<li><p>聚簇索引并不是单独的索引类型,而是一种数据存储方式.叶子页包含行的全部数据,节点页只包含索引列</p>
</li>
<li><p>InnoDB默认使用主键聚集数据,如果没有会选择一个唯一的非空索引作为<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html" target="_blank" rel="noopener">聚簇索引</a></p>
</li>
<li><p>可以把相关数据保存一起,减少磁盘I/O</p>
</li>
<li><p>数据访问更快</p>
</li>
<li><p>插入速度严重依赖插入顺序</p>
</li>
<li><p>更新聚簇索引代价高</p>
</li>
<li><p>可能面临”页分裂”问题,导致占用更多磁盘空间</p>
</li>
<li><p>可能导致全表扫描变慢,由于行比较稀疏或页分裂导致数据存储不连续</p>
</li>
<li><p>二级索引变大,二级索引访问需要两次索引查找</p>
</li>
</ol>
<h3 id="2-3-6-覆盖索引"><a href="#2-3-6-覆盖索引" class="headerlink" title="2.3.6 覆盖索引"></a>2.3.6 覆盖索引</h3><ol>
<li><p>如果一个索引包含所有需要查询的字段的值</p>
</li>
<li><p>覆盖索引必须要存储索引列的值</p>
</li>
<li><p>MySQL不能在索引中执行like 操作,但能在索引中做最左前缀匹配的like比较,因为可以转换为简单的比较操作</p>
</li>
<li><p>延迟关联: 先通过覆盖索引返回需要的主键再通过这些主键关联原表获得需要的行</p>
</li>
</ol>
<h3 id="2-3-7-使用索引扫描做排序"><a href="#2-3-7-使用索引扫描做排序" class="headerlink" title="2.3.7 使用索引扫描做排序"></a>2.3.7 使用索引扫描做排序</h3><ol>
<li><p>只有索引列的顺序和order by 子句的顺序一致时才能使用索引对结果做排序</p>
</li>
<li><p>如果关联多表,则只有当order by子句引用的字段全部为第一个表时才能使用索引排序</p>
</li>
</ol>
<h3 id="2-3-8-压缩索引"><a href="#2-3-8-压缩索引" class="headerlink" title="2.3.8 压缩索引"></a>2.3.8 压缩索引</h3><ol>
<li><p>MyISAM使用前缀压缩减少索引的大小</p>
</li>
<li><p>create table 时通过指定pack_keys控制压缩方式</p>
</li>
</ol>
<h3 id="2-3-9-未使用的索引"><a href="#2-3-9-未使用的索引" class="headerlink" title="2.3.9 未使用的索引"></a>2.3.9 未使用的索引</h3><ol>
<li><p>通过查询INFORMATION_SCHEMA.INDEX_STATISTICES能查到每个索引的使用频率</p>
</li>
<li><p>冗余和重复的索引会降低性能</p>
</li>
</ol>
<h3 id="2-3-10-索引和锁"><a href="#2-3-10-索引和锁" class="headerlink" title="2.3.10 索引和锁"></a>2.3.10 索引和锁</h3><ol>
<li>InnoDB在二级索引上使用共享(读)锁,但访问主键索引需要排他(写)锁,消除了使用覆盖索引的可能</li>
</ol>
<h2 id="2-4-维护索引和表"><a href="#2-4-维护索引和表" class="headerlink" title="2.4 维护索引和表"></a>2.4 维护索引和表</h2><ol>
<li><p>check table 通常能够找出大多数的表和索引的错误</p>
</li>
<li><p>MyISAM表易损坏,InnoDB不容易,损坏可能是硬件或人为错误</p>
</li>
<li><p>MySQL查询优化器通过两个api,一个获取范围大概数据量,一个返回各种类型的数据包括索引基数</p>
</li>
<li><p>减少索引和数据的碎片,B-TREE索引可能碎片化,这会降低效率</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-3/" data-id="cjsvjedgn000vlwt9f32gvdpr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-2/" class="article-date">
  <time datetime="2018-06-30T05:52:39.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《高性能MySQL》阅读笔记/">《高性能MySQL》阅读笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-2/">《高性能MySQL》阅读笔记二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-基准测试"><a href="#1-基准测试" class="headerlink" title="1. 基准测试"></a>1. 基准测试</h3><h4 id="1-1-应用"><a href="#1-1-应用" class="headerlink" title="1.1 应用"></a>1.1 应用</h4><p>验证系统的一些假设</p>
<p>重现系统异常</p>
<p>测试系统当前的运行情况</p>
<p>模拟更高的负载</p>
<p>规划业务增长</p>
<p>测试应用适应可变环境的能力</p>
<p>测试不同硬件,软件和操作系统的配置</p>
<h4 id="1-2-策略"><a href="#1-2-策略" class="headerlink" title="1.2 策略"></a>1.2 策略</h4><p>针对整个系统的整体测试, 集成式</p>
<p>单独测试MySQL, 单组件式</p>
<h4 id="1-3-测试指标"><a href="#1-3-测试指标" class="headerlink" title="1.3 测试指标"></a>1.3 测试指标</h4><ol>
<li><p>吞吐量: 在线事务处理(OLTP),单位为每秒事务数TPS</p>
</li>
<li><p>响应时间或延迟: 百分比响应时间较为代表性</p>
</li>
<li><p>并发性: 任意时间有多少同时发生的并发请求. 关注的是正在工作中的并发操作; 通常是为了测试应用在不同并发下的性能(吞吐量和响应时间)</p>
</li>
<li><p>可扩展性</p>
</li>
</ol>
<h4 id="1-4-方法"><a href="#1-4-方法" class="headerlink" title="1.4 方法"></a>1.4 方法</h4><p>避免常见错误</p>
<p>设计和规划基准测试</p>
<p>基准测试的运行时间设置</p>
<p>获取系统的性能和状态</p>
<p>收集分析绘图</p>
<h4 id="1-5-工具"><a href="#1-5-工具" class="headerlink" title="1.5 工具"></a>1.5 工具</h4><p>集成式测试工具</p>
<ol>
<li><p>ab: Apache http服务器基准测试工具,测试服务器qps, 针对单个url进行尽可能快的压力测试</p>
</li>
<li><p>http_load: 对Web服务器,可以通过输入文件对多个url进行随机测试</p>
</li>
<li><p>JMeter: 测试Web应用和其他入FTP服务器或通过JDBC进行数据库查询测试</p>
</li>
</ol>
<p>单组件式测试工具</p>
<ol>
<li><p>mysqlslap: 模拟服务器负载并输出计时信息</p>
</li>
<li><p>sqlbench: 测试服务器执行查询的速度</p>
</li>
<li><p>super smack: mysql 和postgresql的基准测试工具</p>
</li>
<li><p>database test suite</p>
</li>
<li><p>sysbench: 多线程系统压测工具, 支持mysql,操作系统,和硬件测试</p>
</li>
</ol>
<h3 id="2-服务器性能剖析"><a href="#2-服务器性能剖析" class="headerlink" title="2. 服务器性能剖析"></a>2. 服务器性能剖析</h3><h4 id="2-1-原则"><a href="#2-1-原则" class="headerlink" title="2.1 原则"></a>2.1 原则</h4><ol>
<li><p>性能即响应时间无法;</p>
</li>
<li><p>无法测量就无法有效优化</p>
</li>
</ol>
<h4 id="2-2-书中推荐工具"><a href="#2-2-书中推荐工具" class="headerlink" title="2.2 书中推荐工具"></a>2.2 书中推荐工具</h4><ol>
<li><p>New Relic: 收集分析数据,提供web界面</p>
</li>
<li><p>xhprof: Facebook开源的轻量级PHP性能分析工具</p>
</li>
<li><p>Percona Toolkit: pt-query-digest 生成慢查询日志分析报告</p>
</li>
</ol>
<h4 id="2-3-剖析查询"><a href="#2-3-剖析查询" class="headerlink" title="2.3 剖析查询"></a>2.3 剖析查询</h4><ol>
<li><p>SHOW PROFILE: 将profiling开启后,执行的sql的剖析信息会被记录到临时表, 通过 show profile from query (index)命令即可以获取到执行的过程信息</p>
</li>
<li><p>SHOW STATUS: 非剖析工具,主要用在对于执行完后观察某些计数器的值</p>
</li>
<li><p>使用慢查询日志</p>
</li>
</ol>
<h4 id="2-4-诊断间歇性问题"><a href="#2-4-诊断间歇性问题" class="headerlink" title="2.4 诊断间歇性问题"></a>2.4 诊断间歇性问题</h4><ol>
<li><p>show global status: 通过某些计数器的”尖刺”或”凹陷”分析问题</p>
</li>
<li><p>show processlist: 观察是否有大量线程处于不正常的状态或其他不正常特征</p>
</li>
<li><p>使用innotop: 实时地展示服务器正在发生的事情，监控innodb,监控多个MySQL实例</p>
</li>
<li><p>使用慢查询日志</p>
</li>
</ol>
<h4 id="2-5-其他剖析工具"><a href="#2-5-其他剖析工具" class="headerlink" title="2.5 其他剖析工具"></a>2.5 其他剖析工具</h4><ol>
<li><p>自带的一些INFORMATION_SCHEMA统计表</p>
</li>
<li><p>使用strace工具,pt-iopfofile工具生成I/O活动报告</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-2/" data-id="cjsvjedfl0001lwt96m6qbtd3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-1/" class="article-date">
  <time datetime="2018-06-30T03:21:11.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《高性能MySQL》阅读笔记/">《高性能MySQL》阅读笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-1/">《高性能MySQL》阅读笔记一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-MySQL服务器逻辑架构"><a href="#1-MySQL服务器逻辑架构" class="headerlink" title="1. MySQL服务器逻辑架构"></a>1. MySQL服务器逻辑架构</h1><p>连接/线程处理: 基于C/S的工具类似,实现连接处理,授权认证,安全等.</p>
<p>查询缓存/解析器: 实现查询解析,分析,优化,缓存.内置函数和跨存储引擎如存储过程,触发器,视图等.</p>
<p>存储引擎: 数据的存储和提取.不会解析sql,独立与上层服务器通过api进行通信.</p>
<h1 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2. 并发控制"></a>2. 并发控制</h1><p>每种存储引擎有不同的锁策略和锁粒度</p>
<p>表锁是MySQL中最基本,开销最小的策略,阻塞其他用户对该表的读写操作.写锁比读锁有更高的优先级.</p>
<p>行级锁: InnoDB和[XtraDB][1],行级锁只在存储引擎实现</p>
<p>事务: ACID, 原子性,一致性,隔离性(isolation),持久性(durability).</p>
<p>MySQL默认的[事务隔离级别][2]为可重复读(REPEATABLE READ)</p>
<p>死锁: 不同引擎处理方式不同.InnoDB 处理死锁方法,将持有最少行级排他锁的事务进行回滚</p>
<p>多版本并发控制(MVCC): 如InnoDB, 通过在每行记录后面保存两个列存储创建和删除时的系统版本号.</p>
<h1 id="3-存储引擎"><a href="#3-存储引擎" class="headerlink" title="3. 存储引擎"></a>3. 存储引擎</h1><p>创建表时,MySQL会在数据库子目录下创建一个同名.frm文件保存表的定义</p>
<p>InnoDB: 处理大量的短期事务, 通过间隙锁锁定查询涉及的行和索引中的间隙进行锁定,防止幻影行的插入, 基于聚簇索引创建表.通过一些机制和工具支持真正的热备份.**一般优先考虑InnoDB存储引擎**</p>
<p>MyISAM: 包括全文索引,压缩,空间函数,延迟更新索引键等特性,不支持事务和行级锁,崩溃后无法安全恢复.对于只读数据,表小可以忍受修复操作可以使用该引擎.</p>
<p>如果要使用全文索引,建议用InnoDB加上Sphinx组合替换MyISAM</p>
<p>使用引擎考虑:事务,备份,崩溃恢复,特有特性</p>
<p>日志型应用: MyISAM 或者Archive,因为开销低插入速度快更为适合</p>
<p>对于大数据量需要建立数据仓库,[Infobright][3]和[TokuDB][4]是比较好的解决方案</p>
<p>[1]: <a href="https://mariadb.com/kb/zh-cn/about-xtradb/" target="_blank" rel="noopener">https://mariadb.com/kb/zh-cn/about-xtradb/</a></p>
<p>[2]: <a href="https://zh.wikipedia.org/wiki/事務隔離" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/事務隔離</a></p>
<p>[3]: <a href="http://www.csdn.net/article/2014-08-26/2821379" target="_blank" rel="noopener">http://www.csdn.net/article/2014-08-26/2821379</a></p>
<p>[4]: <a href="http://blog.jobbole.com/109104/" target="_blank" rel="noopener">http://blog.jobbole.com/109104/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-1/" data-id="cjsvjedfh0000lwt91wvl7f74" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx文档笔记/">Nginx文档笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python源码学习/">Python源码学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis文档阅读笔记/">Redis文档阅读笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《HTTP权威指南》阅读笔记/">《HTTP权威指南》阅读笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《TCP-IP详解卷1》阅读笔记/">《TCP/IP详解卷1》阅读笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《现代操作系统》阅读笔记/">《现代操作系统》阅读笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《高性能MySQL》阅读笔记/">《高性能MySQL》阅读笔记</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/18/tcpip-1/">《TCP/IP详解卷1》阅读笔记一</a>
          </li>
        
          <li>
            <a href="/2018/08/18/opsystem-1/">《现代操作系统》阅读笔记一</a>
          </li>
        
          <li>
            <a href="/2018/08/18/opsystem-2/">《现代操作系统》阅读笔记二</a>
          </li>
        
          <li>
            <a href="/2018/08/18/opsystem-3/">《现代操作系统》阅读笔记三</a>
          </li>
        
          <li>
            <a href="/2018/07/26/nginx-1/">Nginx文档笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Whales<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>