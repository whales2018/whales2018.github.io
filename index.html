<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>沧海一粟</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="沧海一粟">
<meta property="og:url" content="https://whales2018.github.io/index.html">
<meta property="og:site_name" content="沧海一粟">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="沧海一粟">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">沧海一粟</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://whales2018.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ds-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/20/ds-1/" class="article-date">
  <time datetime="2018-09-20T03:21:11.000Z" itemprop="datePublished">2018-09-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/20/ds-1/">1. 链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>数据结构与算法这一分类的文章，将采用严蔚敏《数据结构与算法》一书的顺序结合leetcode题目Go实现，实践与理论相结合的方式记录学习过程。</p>
<h1 id="链表常见问题"><a href="#链表常见问题" class="headerlink" title="链表常见问题"></a>链表常见问题</h1><ul>
<li>节点基础操作</li>
<li>快慢指针</li>
<li>链表合并</li>
</ul>
<h2 id="节点增删改查"><a href="#节点增删改查" class="headerlink" title="节点增删改查"></a>节点增删改查</h2><ul>
<li>增删改查，反转</li>
<li>237 删除链表指定节点，画图辅助，修改值和指针指向达到删除链表节点目的</li>
<li>203 删除节点元素</li>
<li>83 有序链表删除重复元素</li>
<li>206 链表反转，画图辅助，临时节点存储，修改指针指向</li>
</ul>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><ul>
<li>876 链表中间节点，快指针两步，慢指针一步，则快指针遍历完即得到中间节点</li>
<li>141 判断链表是否有环，当快指针追上慢指针，则链表有环</li>
<li>234 判断链表是否回文序列，快慢指针找到链表中间节点，反转以中间节点为头节点的链表b，比较原链表和b，遍历到其中一个的尽头如果都相等则为回文序列</li>
<li>160 两个链表交汇节点，两个链表分叉部分的节点数差值为x，双指针分别按1步，快指针在短链表，则快指针遍历完链表时，快指针回到慢链表从头遍历，慢指针遍历完之后回到快链表，则此时快慢指针到达交汇点的节点数相等。需要注意没有交汇点时的情况判断</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/09/20/ds-1/" data-id="cjt4acf380001vjt9v9oitx9b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ds-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/20/ds-2/" class="article-date">
  <time datetime="2018-09-20T03:21:11.000Z" itemprop="datePublished">2018-09-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/20/ds-2/">2. 栈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>数据结构与算法这一分类的文章，将采用严蔚敏《数据结构与算法》一书的顺序结合leetcode题目Go实现，实践与理论相结合的方式记录学习过程。</p>
<h1 id="栈常见问题"><a href="#栈常见问题" class="headerlink" title="栈常见问题"></a>栈常见问题</h1><ul>
<li>运算</li>
<li>最小栈</li>
<li>回溯法</li>
<li>栈与递归</li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><ul>
<li>682 根据规则入栈出栈，最后求和</li>
<li>842 根据规则入栈出栈，最后对比</li>
<li>20 左符号入栈，遇到右符号出栈，最后查看栈是否为空</li>
</ul>
<h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><ul>
<li>155 最小栈设计</li>
</ul>
<ol>
<li>设计为节点包含每次入栈时的最小值</li>
<li>栈维护最小值，压栈时，存x-min，出栈时如果值小于0，则返回最小值且更新最小值min=min-x，如果大于0，则返回x+min</li>
</ol>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><ul>
<li>迷宫求解</li>
</ul>
<h2 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h2><ul>
<li>n皇后</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/09/20/ds-2/" data-id="cjt4acf3c0003vjt9t354my5s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ds-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/20/ds-3/" class="article-date">
  <time datetime="2018-09-20T03:21:11.000Z" itemprop="datePublished">2018-09-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/20/ds-3/">3. 队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>数据结构与算法这一分类的文章，将采用严蔚敏《数据结构与算法》一书的顺序结合leetcode题目Go实现，实践与理论相结合的方式记录学习过程。</p>
<h1 id="队列常见问题"><a href="#队列常见问题" class="headerlink" title="队列常见问题"></a>队列常见问题</h1><ul>
<li>事件驱动模拟</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/09/20/ds-3/" data-id="cjt4acf3d0004vjt9gwkh6vrv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ds-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/20/ds-4/" class="article-date">
  <time datetime="2018-09-20T03:21:11.000Z" itemprop="datePublished">2018-09-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/20/ds-4/">4. 字符串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>数据结构与算法这一分类的文章，将采用严蔚敏《数据结构与算法》一书的顺序结合leetcode题目Go实现，实践与理论相结合的方式记录学习过程。</p>
<h1 id="字符串常见问题"><a href="#字符串常见问题" class="headerlink" title="字符串常见问题"></a>字符串常见问题</h1><ul>
<li>字符串实质是byte数组，可以用数组的方法来解决字符串的问题，字符串数组可以看作二维数组来解决问题</li>
<li>基础操作</li>
<li>回文序列</li>
<li>ASCII码，A-65，a-97，0-48</li>
<li>滑动窗口</li>
</ul>
<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><ul>
<li>分割，替换，取子串</li>
<li>929 过滤重复邮箱地址</li>
</ul>
<h2 id="回文序列"><a href="#回文序列" class="headerlink" title="回文序列"></a>回文序列</h2><ul>
<li>125 筛选26字母和数字字符串，转为数组</li>
<li>680 回文序列变种，允许删除一个元素。则还是按回文序列的规则进行比较，当不匹配时，比较i+1:j序列 或者 i:j-1序列</li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul>
<li>28 子串定位，寻找给定字符串1在字符串2的位置，从字符串2滑动，寻找符合条件的位置直到边界</li>
</ul>
<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/09/20/ds-4/" data-id="cjt4acf3e0005vjt96j5w3n0d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ds-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/20/ds-5/" class="article-date">
  <time datetime="2018-09-20T03:21:11.000Z" itemprop="datePublished">2018-09-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/20/ds-5/">5. 数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>数据结构与算法这一分类的文章，将采用严蔚敏《数据结构与算法》一书的顺序结合leetcode题目Go实现，实践与理论相结合的方式记录学习过程。</p>
<h1 id="数组常见问题"><a href="#数组常见问题" class="headerlink" title="数组常见问题"></a>数组常见问题</h1><ul>
<li>对无序数组进行排序</li>
<li>多维数组数组元素按规则变换</li>
<li>数组按指定行列分组</li>
<li>利用数组作为以下标为key的哈希表</li>
<li>配合额外的数据结构如哈希表等</li>
<li>滑动窗口</li>
<li>动态规划</li>
<li>矩阵</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>977 无序数组元素平方之后升序排序</li>
<li>905 无序数组元素按偶数奇数规则排序</li>
<li>561 无序数组升序排序后，按step为2求和</li>
</ul>
<h2 id="多维数组数组元素按规则变换"><a href="#多维数组数组元素按规则变换" class="headerlink" title="多维数组数组元素按规则变换"></a>多维数组数组元素按规则变换</h2><ul>
<li>解决思路：根据坐标寻找元素按规则变换的数学方程</li>
<li>832 二维数组反转图片，F(i, j) = F(i, ~j) == 1 ? 0 : 1</li>
<li>999 棋盘规则，可以列方程式 F(i, j) = (B(i, j+x) ? 0 : A(i, j+x)) + … F 表示位于该坐标的结果，B 表示某个坐标方向有没有阻隔, A 表示某个坐标方向有没有黑棋</li>
<li>867 坐标转换，L = [[F(i,j),F(i+1,j)]\ …]</li>
<li>766 遍历i,遍历j，需要满足F(i,j) == F(i+x,j+x) 直到F(i+x,j+x)不存在</li>
</ul>
<h2 id="利用数组作为以下标为key的哈希表"><a href="#利用数组作为以下标为key的哈希表" class="headerlink" title="利用数组作为以下标为key的哈希表"></a>利用数组作为以下标为key的哈希表</h2><ul>
<li>448 把数值v对应的数组位置i = v 标记为0，标记为0的原先值v(i)对应的数组位置也标记为0，以此类推，最后遍历一遍数组，如果该位置对应的值不为0，则表明该值为缺失的连续值</li>
</ul>
<h2 id="配合额外的数据结构如哈希表等"><a href="#配合额外的数据结构如哈希表等" class="headerlink" title="配合额外的数据结构如哈希表等"></a>配合额外的数据结构如哈希表等</h2><ul>
<li>217 检查数组是否存在重复</li>
<li>914 计数公约数</li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul>
<li>记录窗口起始点，窗口实时移动</li>
<li>窗口起始点变换条件</li>
<li>窗口记录值时机</li>
<li>674 最长的递增子数组的大小，比较每个窗口的大小</li>
<li>643 窗口大小为4在数组滑动，求每个窗口平均值，最后得出4元连续子数组最大平均值</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划的套路一般可以分为三个步骤，跟多维数组数组元素按规则变换有点类似，本质都是找到对应的数学方程式：</p>
<ol>
<li>定义状态</li>
<li>状态转移方程</li>
<li>边界</li>
</ol>
<ul>
<li>746 定义F(s)为选定坐标s时的最小和, F(s) = A(s) + min(F(s-1),F(s-2)),F(1) = A(1), F(2) = A(2), 结果为min(F(len(A)-1),F(len(A)-2))</li>
</ul>
<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/09/20/ds-5/" data-id="cjt4acf3f0007vjt9sqhq8uju" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ds-6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/20/ds-6/" class="article-date">
  <time datetime="2018-09-20T03:21:11.000Z" itemprop="datePublished">2018-09-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/20/ds-6/">6. 二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>数据结构与算法这一分类的文章，将采用严蔚敏《数据结构与算法》一书的顺序结合leetcode题目Go实现，实践与理论相结合的方式记录学习过程。</p>
<h1 id="二叉树常见问题"><a href="#二叉树常见问题" class="headerlink" title="二叉树常见问题"></a>二叉树常见问题</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/09/20/ds-6/" data-id="cjt4acf3h0008vjt93h8qilp8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-tcpip-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/18/tcpip-1/" class="article-date">
  <time datetime="2018-09-18T03:21:11.000Z" itemprop="datePublished">2018-09-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《TCP-IP详解卷1》阅读笔记/">《TCP/IP详解卷1》阅读笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/18/tcpip-1/">《TCP/IP详解卷1》阅读笔记一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/09/18/tcpip-1/" data-id="cjt4acf3x000tvjt90i7naojj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-opsystem-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/18/opsystem-1/" class="article-date">
  <time datetime="2018-08-18T03:21:11.000Z" itemprop="datePublished">2018-08-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/opsystem-1/">《现代操作系统》阅读笔记一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一-进程与线程"><a href="#一-进程与线程" class="headerlink" title="一. 进程与线程"></a>一. 进程与线程</h1><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><ol>
<li>系统初始化</li>
<li>正在进行的进程调用进程创建系统调用</li>
<li>用户请求</li>
<li>批处理作业初始化</li>
</ol>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><ol>
<li>正常退出</li>
<li>出错退出，自愿</li>
<li>严重错误，非自愿</li>
<li>被其他进程杀死</li>
</ol>
<h2 id="进程层次结构"><a href="#进程层次结构" class="headerlink" title="进程层次结构"></a>进程层次结构</h2><ol>
<li>系统启动初始化由init特殊进程运行</li>
</ol>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ol>
<li>运行，就绪，阻塞</li>
<li>进程中断处理，启动，停止由操作系统进程调度程序控制</li>
</ol>
<h2 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h2><ol>
<li>操作系统维护一个进程表，每个进程占用一个进程表项（进程控制块PCB）</li>
<li>PCB：包含了进程状态的重要信息，程序计数器，堆栈指针，内存分配状况，打开的文件，进程由运行状态转换到就绪或阻塞需要保存的信息等</li>
<li>进程切换：保存寄存器值，设置新的堆栈，C中断服务程序运行，调度程序决定下一个进程运行，开始运行新的当前进程</li>
<li>CPU利用率：进程等待IO操作时间与其停留在内存中时间的比对P，内存中同时有N个进程，则利用率=1-P的N次方</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ol>
<li>传统：每个进程有一个地址空间和一个控制线程</li>
<li>对于大量IO操作，多线程允许这些活动重叠进行</li>
<li>所有线程都有完全一样的地址空间</li>
<li>线程共享进程内容：地址空间，全局变量，打开文件，子进程，信号与信号处理程序</li>
<li>线程独有：程序计数器，寄存器，堆栈，状态</li>
<li>线程创建的线程与当前线程平等，线程可以阻塞等待其他线程返回，线程也可以主动让出CPU</li>
</ol>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><ol>
<li>线程的调度不需要内核，内核不知道多线程的存在，由用户程序自己控制内核切换，切换快</li>
<li>可以在不支持线程的操作系统实现，允许进程定制调度算法</li>
<li>同一个进程只能同时有一个线程在运行，如果有一个线程阻塞于系统调用，则整个进程阻塞</li>
<li>执行系统调用时将导致所属进程被中断，而内核级线程只导致线程中断</li>
</ol>
<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><ol>
<li>多核机器，一个进程的多个线程可以同时处理</li>
<li>线程用户态运行内核态调度切换</li>
</ol>
<h3 id="混合线程模型"><a href="#混合线程模型" class="headerlink" title="混合线程模型"></a>混合线程模型</h3><ol>
<li>用户线程由运行时库调度器管理，内核线程由操作系统调度器管理</li>
<li>一对一，多对一，多对多</li>
</ol>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>IPC问题</p>
<ol>
<li>进程传递信息给另一个</li>
<li>多个进程在关键活动不会出现交叉</li>
<li>正确的顺序</li>
</ol>
<h3 id="通信方法"><a href="#通信方法" class="headerlink" title="通信方法"></a>通信方法</h3><ol>
<li>共享内存</li>
<li>管道</li>
<li>消息队列</li>
<li>socket</li>
<li>远程过程调用RPC</li>
</ol>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><ol>
<li>对进程共享资源的程序片段称作临界区</li>
<li>避免竞争条件：任何两个进程不能同时处于临界区，不对CPU作假设，临界区外运行的进程不能阻塞其他进程，不能使进程无限等待进入临界区</li>
</ol>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><ol>
<li>互斥锁+条件变量</li>
<li>信号量pv操作</li>
</ol>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><ol>
<li>衡量调度：吞吐量系统每小时完成的作业数，周转时间批处理到结束的平均统计时间，CPU利用率</li>
</ol>
<h1 id="二、存储管理"><a href="#二、存储管理" class="headerlink" title="二、存储管理"></a>二、存储管理</h1><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ol>
<li>地址空间：一个进程可用于寻址内存的一套地址集合</li>
<li>每个进程的地址空间映射到物理内存的不同部分</li>
<li>程序装载到内存中连续地址。程序的起始物理地址装载到基址寄存器，程序的长度装载到界限寄存器。进程寄存器相关值由内核维护</li>
</ol>
<h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><ol>
<li>进程完整调入内存运行一段时间，存回磁盘</li>
<li>被唤醒时重新装载到内存，由基址寄存器和界限寄存器重新映射物理内存</li>
</ol>
<h2 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h2><ol>
<li>使用位图：每个分配单元对应1位，0表示空闲</li>
<li>使用链表：每个节点代表一块内存，便于交换</li>
</ol>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>每个程序有自己的地址空间，被分割成多个快，即页面，每一页有连续的地址范围。这些页被映射到物理内存，不一定需要在内存中才能运行，<br>当程序引用到一部分不在物理内存中的地址空间时，操作系统负责将缺失的部分装入物理内存并重新执行失败指令。当程序等待它的一部分读入内存时，可以让出CPU</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ol>
<li>虚拟地址：没有虚拟内存时，系统直接将虚拟地址送到内存总线。使用虚拟内存，则送到内存管理单元MMU映射为物理地址</li>
<li>页面：虚拟地址空间按照固定大小划分为固定大小的页面</li>
<li>页框：物理内存对应页面的单元</li>
<li>页面找无法映射物理内存时，CPU陷入缺页中断page fault，操作系统选择很少使用的页框，将内容写入磁盘，随后将页面对应的内容读入到内存，修改映射关系，重新执行指令</li>
<li>MMU页表：虚拟地址分成虚拟页号和偏移量，虚拟页号作页表索引，由页表项找到页框号</li>
<li>引入TLB快表加快虚拟地址到物理地址的转换</li>
<li>引入多级页表，解决虚拟地址空间巨大的问题</li>
<li>页面置换算法：最近未使用页面置换算法，先进先出等</li>
<li>页面大小：小页面减少内存占用，但页表太大，磁盘与内存传输是按页进行，进程切换页表装入硬件寄存器也会变慢。大页面则容易产生更大碎片，浪费内存</li>
</ol>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ol>
<li>静态链接：将被调用函数的库程序全部装载生成二进制可执行文件，耗空间，每次都需要重新编译</li>
<li>动态链接：加载了一小段能够在运行时绑定被调用函数的存根例程，在第一次被调用时被装载</li>
</ol>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><ol>
<li>机制思想：进程发起一个系统调用，将一个文件映射到其虚拟地址空间的一部分，在映射共享的页面时不会读入页面的内容，而是在访问页面时才读入。进程退出或解除文件映射时所有改动的页面会被写回到文件</li>
<li>如果多个进程同时映射了同一份文件，它们就可以通过共享内存通信</li>
</ol>
<h3 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h3><ol>
<li>分页守护进程定时检查内存状态，通过置换算法维护空闲页框</li>
</ol>
<h3 id="进程创建-1"><a href="#进程创建-1" class="headerlink" title="进程创建"></a>进程创建</h3><ol>
<li>确定程序和数据初始大小，创建页表，内存中为页表分配空间初始化</li>
<li>磁盘交换区中分配空间</li>
<li>程序正文和数据对交换区空间初始化，以便进程缺页中断时可以调入需要的页面</li>
<li>页表和磁盘交换区的信息存储在进程表中</li>
</ol>
<h3 id="进程执行"><a href="#进程执行" class="headerlink" title="进程执行"></a>进程执行</h3><ol>
<li>重置MMU，刷新TLB，新进程页表成为当前页表</li>
</ol>
<h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><ol>
<li>确定缺页的虚拟地址</li>
<li>确定缺失的页面，确定磁盘上的位置</li>
<li>找到合适的页框，读入页面</li>
<li>备份指令，重新执行</li>
<li>正在进行IO操作的页面不会被移出内存</li>
</ol>
<h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><ol>
<li>最后一个进程退出时，释放页表，页面和页面在硬盘所占用的空间</li>
</ol>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><ol>
<li>每个段由一个从0到最大的线性地址序列构成，每个段都是独立地址空间</li>
<li>寻址：段号+段内地址</li>
<li>简化对长度经常变化的数据结构管理，有利于各个过程单独编译链接</li>
<li>使程序和数据可以划分为逻辑上独立的地址空间，有助于共享，连接和保护</li>
<li>内存段与段之间的空闲内存外部碎片可以通过内存紧缩</li>
<li>分段和分页的结合：段内进行分页，提供二维的虚拟内存</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/08/18/opsystem-1/" data-id="cjt4acf3s000kvjt9xusyngtp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-opsystem-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/18/opsystem-2/" class="article-date">
  <time datetime="2018-08-18T03:21:11.000Z" itemprop="datePublished">2018-08-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/opsystem-2/">《现代操作系统》阅读笔记二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="三、文件系统"><a href="#三、文件系统" class="headerlink" title="三、文件系统"></a>三、文件系统</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ol>
<li>文件命名，文件结构，文件类型</li>
<li>文件存取：顺序存取，随机存取</li>
<li>文件属性：如权限，创建修改时间等</li>
<li>文件操作：常用系统调用如创建，打开等；open：文件属性和磁盘地址装入内存</li>
</ol>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>层次目录系统，路径名</li>
<li>目录操作：常用系统调用如创建，打开等；硬连接：文件的节点技术器增加，修改同一份文件。软连接只是符号连接，快捷方式，可以跨越磁盘界限</li>
</ol>
<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><ol>
<li>主引导记录MBR：磁盘的0号扇区，引导计算机</li>
<li>分区表：MBR后面，记录每个分区的起始结束地址</li>
<li>分区结构：引导块，超级块，空闲管理，i节点，根目录，文件和目录</li>
<li>过程：计算机被引导，BIOS读入并执行MBR，确定活动分区，读入并执行第一个块引导快boot block，引导块中的程序将装载该分区中的操作系统</li>
<li>每个分区都从一个启动块开始</li>
<li>超级块：启动块之后，包括文件系统类型用的魔数，文件系统中数据块的数量等</li>
<li>空闲管理：超级块之后，位图或链表形式</li>
</ol>
<h2 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h2><ol>
<li>连续分配：删除时会产生磁盘空洞，写入时需要先挑选合适大小的磁盘空洞，常见于CD-ROM</li>
<li>链表分配：不利于随机存取，指针占了一些字节，致使存储数据不再是2的整数幂</li>
<li>文件分配表FAT：把磁盘块的指针放在内存的一个表中，目录项中记录起始块号即可。缺点是需要将整个表放在内存中，不适用于大磁盘</li>
<li>i节点：每个文件一个i节点数据结构，列出文件属性和文件块的磁盘地址，具有指针可以指向包含磁盘块地址的块的地址</li>
</ol>
<h2 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h2><ol>
<li>如NTFS和Linux ext3</li>
<li>基本思想：保存一个用于记录系统下一步将要做什么的日志，当系统崩溃重启时可以查看日志，完成未完成任务</li>
<li>先写日志项列出要完成的动作，写入磁盘，完成动作后擦除日志项</li>
</ol>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><ol>
<li>和文件相关的系统调用POSIX接口指向虚拟文件系统，由虚拟文件系统调用底层实际的文件系统</li>
</ol>
<h2 id="文件系统管理和优化"><a href="#文件系统管理和优化" class="headerlink" title="文件系统管理和优化"></a>文件系统管理和优化</h2><ol>
<li>选定块大小：性能和空间利用率不可兼得</li>
<li>记录空闲块：位图，空闲列表</li>
<li>磁盘配额：通过打开文件表中的配额指针，找到配额表中用户的配额表项。</li>
<li>文件系统的一致性：块检查检查使用表和空闲表并进行校正，目录检查检查文件使用表和文件i节点的计数。rm操作只修改i节点，没有把磁盘块返回空闲表</li>
</ol>
<h2 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h2><p>如果只需要读一个字，内存比磁盘方位快百万数量级</p>
<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><ol>
<li>逻辑上属于磁盘，实际保存在内存中。与分页类似，置换算法类似</li>
<li>系统调用SYNC强制性把全部修改过的块写回磁盘，若没有SYNC就移动磁盘，则数据丢失</li>
</ol>
<h3 id="块提前读"><a href="#块提前读" class="headerlink" title="块提前读"></a>块提前读</h3><ol>
<li>在需要用到块时，试图提前将其写入高速缓存，提高命中率，如完成k块操作时，预读k+1块到高速缓存</li>
<li>不适用于随机存取文件</li>
</ol>
<h3 id="减少磁盘臂运动"><a href="#减少磁盘臂运动" class="headerlink" title="减少磁盘臂运动"></a>减少磁盘臂运动</h3><ol>
<li>把有可能顺序存取的块放在一起，最好是同一个柱面，减少磁盘臂运动</li>
<li>使用i节点的文件系统中，需要两次磁盘访问，访问i节点和访问块。所以将i节点存放在磁盘中部，可以减少寻道时间</li>
</ol>
<h3 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h3><ol>
<li>通过移动或复制，使空闲空间连成一片</li>
</ol>
<h1 id="四、输入-输出"><a href="#四、输入-输出" class="headerlink" title="四、输入/输出"></a>四、输入/输出</h1><h2 id="IO硬件原理"><a href="#IO硬件原理" class="headerlink" title="IO硬件原理"></a>IO硬件原理</h2><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><ol>
<li>块设备：硬盘，CD-ROM，USB</li>
<li>字符设备：不可寻址没有寻道操作，打印机，网路接口，鼠标等</li>
<li>时钟，内存映射显示器等</li>
</ol>
<h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><ol>
<li>有寄存器用来与CPU通信</li>
<li>数据缓冲区</li>
<li>内存映射IO：每个控制寄存器映射到内存空间中被分配唯一的内存地址</li>
<li>避免对设备控制器进行高速缓存，操作系统必须管理选择性高速缓存</li>
<li>DMA：直接存储器存取，调控多个设备的数据传送</li>
<li>中断：设备中断发出信号，由中断控制器检测</li>
</ol>
<h3 id="IO软件原理"><a href="#IO软件原理" class="headerlink" title="IO软件原理"></a>IO软件原理</h3><ol>
<li>设备独立性</li>
<li>统一命名</li>
<li>错误处理</li>
<li>同步阻塞，异步中断驱动：大部分物理IO是异步的，CPU启动传输便去做别的</li>
<li>缓冲</li>
<li>共享设备和独占设备</li>
<li>程序控制IO：轮询设备寄存器是否就绪，直到全部IO完成，一直占用CPU</li>
<li>中断驱动IO：中断发生在每个字符上</li>
<li>DMA控制IO：将中断的次数从每个字符减少的每个缓冲区</li>
<li>设备驱动程序：为了访问设备的硬件，通常必须是操作系统内核的一部分</li>
</ol>
<h2 id="盘"><a href="#盘" class="headerlink" title="盘"></a>盘</h2><p>磁盘组织成柱面，每个柱面包含若干磁道，磁道数与垂直堆叠的磁头个数相同，磁道分成若干扇区</p>
<ol>
<li>SATA：磁盘驱动器包含微控制器，负责高速缓存，重叠寻道，坏块重映等</li>
<li>RAID：将一个装满磁盘的盒子安装到计算机，用RAID控制器替换磁盘控制器</li>
</ol>
<h3 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h3><ol>
<li>磁盘读写时间因素：寻道占主导，旋转延迟，实际数据传输</li>
<li>磁盘驱动程序维护一张表，按柱面号索引，每个柱面未完成的请求组成一个链表</li>
<li>SSF：最短寻道优先算法，获得最小响应时间与公平性有冲突</li>
<li>电梯算法：上下移动完成未完成的请求</li>
<li>磁盘控制器高速缓存：每次将邻近的扇区也读取</li>
</ol>
<h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><ol>
<li>时钟负责维护时间，根据已知的时间间隔产生中断。防止进程垄断CPU等</li>
<li>大多数计算机具有一个由电池供电的备份时钟</li>
</ol>
<h3 id="时钟软件"><a href="#时钟软件" class="headerlink" title="时钟软件"></a>时钟软件</h3><ol>
<li>维护日时间，防止进程超时，记录CPU使用，处理alarm系统调用，监视定时器，统计信息收集</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/08/18/opsystem-2/" data-id="cjt4acf3t000mvjt9qaicrb8n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-opsystem-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/18/opsystem-3/" class="article-date">
  <time datetime="2018-08-18T03:21:11.000Z" itemprop="datePublished">2018-08-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/opsystem-3/">《现代操作系统》阅读笔记三</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="五、死锁"><a href="#五、死锁" class="headerlink" title="五、死锁"></a>五、死锁</h1><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ol>
<li>可抢占资源：如存储器，两个进出互相等待对方占有的资源时，其中一方可以释放可抢占性资源，另一方可以顺利执行</li>
<li>不可抢占资源：无法把资源从占有它的进程抢占过来</li>
</ol>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ol>
<li>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，该进程集合就是死锁</li>
<li>死锁条件：互斥条件，占有和等待条件，不可抢占条件，环路等待条件</li>
<li>处理死锁策略：检测恢复，仔细对资源分配动态避免，破坏死锁条件之一</li>
<li>检测：需要查阅相关检测算法</li>
<li>恢复：利用抢占恢复，回滚恢复，杀死进程</li>
</ol>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><ol>
<li>尽量做到尽可能少的进程可以真正请求资源</li>
<li>破坏占有和等待条件：进程在开始执行前一次性请求所需全部资源，另一种，是进程请求资源时先释放已经持有，再一次性请求</li>
<li>破坏不可抢占条件：对资源进行虚拟化，由底层进行实际的调用。不适用于操作系统或数据库的记录</li>
<li>避免出现环路等待：对资源进行编号，每个进程请求需要按照资源的顺序提出</li>
<li>两阶段加锁：第一阶段将所需记录加锁，如果遇到已经被加锁记录，则释放所有记录，重新第一阶段，第二阶段修改数据然后释放</li>
<li>通信死锁：超时</li>
<li>活锁：进程在临界区进行轮询，则可能出现没有进程阻塞，但进程一直尝试失败，常见于资源不足</li>
<li>饥饿：资源分配迟迟没有轮到该进程</li>
</ol>
<h1 id="六、多媒体操作系统"><a href="#六、多媒体操作系统" class="headerlink" title="六、多媒体操作系统"></a>六、多媒体操作系统</h1><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><ol>
<li>特征：使用极高的数据率，多媒体要求实时回放</li>
<li>要求：存储量大需要进行压缩，实时数据传输</li>
<li>视频压缩：编码算法和解码算法的速度根据场景不同考量，不必100%可逆，允许有损</li>
<li>音频压缩：波形编码傅里叶变换，感知编码</li>
</ol>
<h1 id="七、多处理机系统"><a href="#七、多处理机系统" class="headerlink" title="七、多处理机系统"></a>七、多处理机系统</h1><h2 id="多处理机操作系统"><a href="#多处理机操作系统" class="headerlink" title="多处理机操作系统"></a>多处理机操作系统</h2><ol>
<li>每个CPU有自己的操作系统：无法充分利用资源，任务分配均衡等</li>
<li>主从多处理机：主处理机容易成为瓶颈过载</li>
<li>对称多处理机：把操作系统分割成多个临界区，每个临界区由其互斥信号量保护</li>
</ol>
<h2 id="多处理机同步，调度"><a href="#多处理机同步，调度" class="headerlink" title="多处理机同步，调度"></a>多处理机同步，调度</h2><ol>
<li>分时</li>
<li>空间共享：多个CPU上同时调度多个线程</li>
<li>群调度：一组相关线程作为一个单位调度，一个群的成员在不同的CPU上同时进行，群中所有成员共同开始和结束时间片</li>
</ol>
<h1 id="八、安全"><a href="#八、安全" class="headerlink" title="八、安全"></a>八、安全</h1><h2 id="目标与威胁"><a href="#目标与威胁" class="headerlink" title="目标与威胁"></a>目标与威胁</h2><ol>
<li>数据机密性–数据暴露</li>
<li>数据完整性–数据篡改，数据遗失</li>
<li>系统可用性–拒绝服务</li>
<li>排外性–病毒控制</li>
</ol>
<h2 id="密码学原理"><a href="#密码学原理" class="headerlink" title="密码学原理"></a>密码学原理</h2><ol>
<li>密钥：算法的加密参数</li>
<li>加密算法公开，加密安全性由独立于算法的密钥决定</li>
<li>公钥加密：加密运算比较简单，没有密钥的解密运算十分繁琐。公钥是加密密钥，私钥用于解密</li>
<li>单向函数：f(x)可容易计算出y值，给定y值不能计算x，也称作加密散列函数</li>
<li>数字签名：对文档运行单向散列函数如MD5，文档拥有者用私钥计算得到D(散列值)，接收方用发送方公钥计算得到E(D(散列值))得到实际散列值，再比较</li>
</ol>
<h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><ol>
<li>域：一对组合，指定一个对象和一些可在其上运行的操作子集</li>
<li>基本原则：最低权限原则，每个域拥有最少对象和满足其完成工作的最少权限，安全性最好</li>
<li>unix：进程的域由(UID,GID)定义，每个进程分为用户部分和核心部分，执行系统调用时，从用户态切换到内核态，核心部分可以访问与用户部分不同的对象集，这样系统调用引发域切换</li>
<li>访问控制表与权能字</li>
<li>隐写术：如将实际信息隐藏在图片中等</li>
</ol>
<h2 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h2><ol>
<li>口令</li>
<li>一次性口令，如网上银行银盾等</li>
<li>挑战响应认证，密码问题等</li>
<li>实物认证</li>
<li>生物识别认证</li>
</ol>
<h2 id="内部安全"><a href="#内部安全" class="headerlink" title="内部安全"></a>内部安全</h2><ol>
<li>逻辑炸弹</li>
<li>后门陷阱</li>
<li>登录欺骗</li>
</ol>
<h2 id="代码漏洞"><a href="#代码漏洞" class="headerlink" title="代码漏洞"></a>代码漏洞</h2><ol>
<li>缓冲区溢出</li>
<li>代码注入：系统调用时，如命令行</li>
<li>权限提升攻击：利用计划任务进行攻击等</li>
</ol>
<h2 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h2><ol>
<li>木马攻击</li>
<li>病毒</li>
<li>蠕虫</li>
</ol>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ol>
<li>防火墙</li>
<li>反病毒扫描，完整性检查，行为检查捕捉系统调用</li>
<li>代码签名</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/08/18/opsystem-3/" data-id="cjt4acf3v000pvjt9h0acwg9v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/17/docker-1/" class="article-date">
  <time datetime="2018-08-17T14:44:38.000Z" itemprop="datePublished">2018-08-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/17/docker-1/">Docker文档与实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="镜像与容器"><a href="#镜像与容器" class="headerlink" title="镜像与容器"></a>镜像与容器</h2><ul>
<li>通过<a href="https://docs.docker.com/get-started/part2/" target="_blank" rel="noopener">官网文档</a>例子构建镜像，可以用镜像运行多个容器。</li>
<li>镜像的发布与拉取，类似于github操作</li>
</ul>
<h2 id="服务组"><a href="#服务组" class="headerlink" title="服务组"></a>服务组</h2><ul>
<li>大的系统往往需要拆分成多个服务，每个服务构建成独立的镜像。而一个服务组可以统一管理各个服务的部署</li>
<li>通过docker-compose.yml配置，可以配置服务组，包含不同服务使用的镜像，容器数量，资源分配，重启策略，端口，网络</li>
<li>docker stack deploy -c docker-compose.yml $services_name</li>
<li>这里的部署前提是docker swarm init，启动集群管理，当前机器为其中的一个节点</li>
<li>部署之前需要确认节点有配置所需要的镜像</li>
</ul>
<h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><ul>
<li>docker swarm init 将当前节点作为管理节点</li>
<li>其他机器可以通过docker swarm join 加入集群，作为其中的一个节点，服务组部署启动的容器将被分布在集群的节点上</li>
</ul>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><ul>
<li>docker-compose.yml 引入可视化服务，redis服务</li>
<li>volumes: 在redis容器内文件系统创建/data，通过映射到宿主系统的实际文件目录，redis数据将可以持久保存在宿主而不会因为容器删除而被删除</li>
<li>通过可视化我们可以直观地看到不同节点运行的服务</li>
</ul>
<h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><h2 id="开发最佳实践"><a href="#开发最佳实践" class="headerlink" title="开发最佳实践"></a>开发最佳实践</h2><ul>
<li>选择合适的基础镜像，避免构建的镜像太大</li>
<li>多阶段构建，如果不使用多阶段构建，则尽量减少层数</li>
<li>创建一个公共基础镜像，docker只需要加载一次并缓存它</li>
<li>需要考虑基于生产镜像构建用于debug的镜像</li>
<li>添加有意义的镜像tag，包含版本信息，运行环境等</li>
<li>避免在容器存储层写数据，将会使容器膨胀，IO也不如使用数据卷高效</li>
<li>敏感数据使用secrets，非敏感使用configs</li>
<li>尽量使用swarm方式部署，可扩展，配置化，优雅重启，具备一些额外功能如secrets，configs，可以自动获取需要的镜像不需要手动拉取</li>
<li>使用CI/CD自动构建，打tag，测试</li>
</ul>
<h2 id="Dockerfile最佳实践"><a href="#Dockerfile最佳实践" class="headerlink" title="Dockerfile最佳实践"></a>Dockerfile最佳实践</h2><ul>
<li>FROM: 从指定的镜像创建一层，COPY: 从Docker客户端当前目录拷贝文件，RUN: 执行命令，CMD: 容器启动执行命令，容器启动时，添加一层可写容器层在镜像基础上，所有的修改仅发生在这一层</li>
<li>执行docker build时，指定目录为build context，上下文会发送给Docker daemon</li>
<li>.dockerignore 类似.gitignore</li>
<li>多阶段构建有助于减小镜像大小和层数，不需要的包不装，构建下一层前清除当前层不需要的东西</li>
<li>应用解耦: 尽可能一个容器一个进程，通过容器间通信配置可以解决依赖</li>
<li>减少层次: RUN，COPY，ADD创建实际的层，其他指令创建临时中间层</li>
<li>构建时指令顺序执行时会检查现有镜像的缓存</li>
<li>从已经缓存的基础镜像开始，下一个指令检查基础镜像的子镜像是否有匹配</li>
<li>ADD，COPY是否使用缓存会通过比较文件指纹</li>
</ul>
<h2 id="创建基础镜像"><a href="#创建基础镜像" class="headerlink" title="创建基础镜像"></a>创建基础镜像</h2><ul>
<li>FROM scratch</li>
</ul>
<h2 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h2><ul>
<li>同一个Dockerfile</li>
<li>多个FROM，通过–from，下一阶段可以通过引用上一阶段构建好的镜像临时容器中获取需要的文件或程序</li>
<li>可以只构建指定阶段，也可以直接引用其他镜像</li>
</ul>
<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><h2 id="网络驱动"><a href="#网络驱动" class="headerlink" title="网络驱动"></a>网络驱动</h2><ul>
<li>可插拔</li>
<li>bridge: 独立容器通信使用，适用于同一个宿主不同容器通信</li>
<li>host: 容器直接使用宿主机的网络，swarm不可用。适用于docker不隔离而容器隔离</li>
<li>overlay: 连接多个Docker daemon，用于支持集群swarm services。适用于容器运行在不同宿主，或多服务间通信</li>
<li>macvlan: 分配MAC地址给容器，Docker daemon通过MAC地址路由。适用于从虚拟机迁移</li>
<li>none: 禁用网络</li>
<li>docker network ls 可以看见已有的网络及对应的驱动类型</li>
</ul>
<h2 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h2><ul>
<li>分为默认和自定义</li>
<li>使用默认时，每个容器都需要打开指定端口。使用自定义网络时，处于同一网络的容器间端口是相互暴露，而只需要供外部访问的容器打开端口即可</li>
<li>使用自定义网络，容器可以加入和移出自定义网络</li>
<li>自定义网络有单独的配置文件</li>
<li>默认网络使用–link参数可以使容器间共享环境变量，自定义网络则需要考虑从共享数据卷，docker-compose，swarm services实现环境变量共享</li>
<li>自定义网络通过-p参数指定对其他网络的暴露端口</li>
<li>容器创建时可以指定加入的网络，已经运行的可以通过docker network connect加入</li>
<li>docker attach 将连接宿主与容器的标准输入输出错误流</li>
<li>实践可以参考<a href="https://docs.docker.com/network/network-tutorial-standalone/" target="_blank" rel="noopener">https://docs.docker.com/network/network-tutorial-standalone/</a></li>
</ul>
<h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><ul>
<li>容器与宿主没有隔离，容器的端口直接使用宿主的端口</li>
<li>可以用于swarm services，如果容器绑定指定端口，则一个节点只能启动一个容器</li>
</ul>
<h2 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h2><ul>
<li>用于创建分布式网络连接多个docker daemon，路由转发数据包</li>
<li>docker swarm init 初始化时，docker network ls 可以查看到，默认网络ingress</li>
<li>同一个docker daemon下的container通信用默认的bridge网络docker_gwbridge</li>
<li>每一个docker daemon 需要开放系列端口：TCP2377用于集群的管理通信，TCP7946和UDP7946用于节点间通信，UDP4789用于overlay网络转发</li>
<li>自定义overlay网络，可以–opt encrypted加密节点数据传输</li>
<li>可以自定义默认ingress的配置，需要通过移除和重建的方式</li>
<li>修改docker_gwbridge配置时，需要停止docker，也是通过移除和重建的方式</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>外部访问容器：通过端口映射将容器端口暴露</li>
<li>容器互联：基础服务容器不对外暴露端口，只供应用层服务容器访问，则传统方式通过–link手动互联，更好的方式是自定义网络，将容器加入同一个网络。Docker通过提供环境变量和更新host文件提供基础服务容器连接信息。</li>
</ul>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><ul>
<li>数据卷作为宿主文件系统的一部分，由docker管理，非docker进程无法修改，官方推荐最佳数据持久化方式</li>
<li>可以同时挂载到多个容器，可以同时读写</li>
<li>可以存储数据到云端</li>
<li>可以方便的进行数据迁移</li>
</ul>
<h3 id="bind-mounts"><a href="#bind-mounts" class="headerlink" title="bind mounts"></a>bind mounts</h3><ul>
<li>可以在宿主任何位置存储，非docker进程可以修改</li>
<li>直接将宿主的文件或文件夹挂载到容器，不利于管理</li>
<li>使用场景：共享配置文件如dns，在开发环境容器进行打包时可以生成包到指定路径，</li>
</ul>
<h3 id="tmpfs-mounts"><a href="#tmpfs-mounts" class="headerlink" title="tmpfs mounts"></a>tmpfs mounts</h3><ul>
<li>存在宿主内存，而不是容器可写存储层</li>
<li>主要基于性能考虑，如大量数据写时</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>文档帮助我们快速入门及对docker的整体有个大体了解。通过官网的实践例子，我们对docker不再陌生，剩下的则是实际开发生产解决具体问题，以下的几个问题还需要在实际应用过程中进行总结。</li>
<li>如何更快构建更小的镜像，需要了解Dockerfile各个指令，多阶段构建，构建缓存使用等</li>
<li>如何利用集群使服务高效便捷地扩展，如何编排服务组，分配资源等</li>
<li>如何利用网络通信，使不同容器，服务，节点间进行解耦合作</li>
<li>如何解决不同容器，服务，节点间数据持久化，共享</li>
<li>实际生产监控与报警</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/08/17/docker-1/" data-id="cjt4acf350000vjt94abqgevn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/26/nginx-1/" class="article-date">
  <time datetime="2018-07-26T03:21:11.000Z" itemprop="datePublished">2018-07-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/26/nginx-1/">Nginx文档笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><ol>
<li><a href="https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/" target="_blank" rel="noopener">安装文档</a></li>
<li>Ubuntu:除了文档列出的依赖，额外依赖<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br><span class="line">sudo apt install  libxml2-dev</span><br><span class="line">sudo apt install libxslt1-dev</span><br><span class="line">sudo apt install libgd-dev</span><br><span class="line">sudo apt install libgeoip-dev</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="二、nginx管理"><a href="#二、nginx管理" class="headerlink" title="二、nginx管理"></a>二、nginx管理</h1><ol>
<li>一个master进程和多个worker进程，如果缓存开启，则缓存加载和缓存管理两个进程也在初始化运行</li>
<li>nginx通过信号管理，除了nginx -s quit/reload/reopen/stop 也可以通过kill 命令发送信号给master进程</li>
</ol>
<h1 id="三、Web服务器"><a href="#三、Web服务器" class="headerlink" title="三、Web服务器"></a>三、Web服务器</h1><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><ol>
<li>root 指定资源根目录</li>
<li>location 匹配url， =普通字符串匹配，～表示正则匹配</li>
<li>sendfile，sendfile_max_chunk：允许数据从一个文件描述符直接拷贝到另外一个，指定分片大小避免较快的连接长期占用worker进程</li>
<li>tcp_nodelay：禁用nagle算法，避免延迟响应，配合keepalive</li>
<li>backlog：支持更多连接，需要配合内核配置优化</li>
</ol>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><ol>
<li>proxy_pass: 请求发送到指定服务组</li>
<li>proxy_bind：如果代理服务器有多个网卡，则与上游服务连接时可以指定ip地址</li>
<li>proxy_set_header，proxy_buffer_size，proxy_timeout，proxy_connect_timeout等</li>
<li>SSL: 基本原理与配置与https一致</li>
</ol>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><ol>
<li>gzip</li>
<li>gzip_types</li>
<li>gzip_min_length：低于这个阈值不会进行压缩</li>
<li>gzip_proxied：如果请求来自代理服务器，则不会进行压缩，所以通过检查请求的cache-control，符合条件的才进行压缩</li>
<li>gzip_static：允许直接发送压缩文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_types      text/plain application/xml;</span><br><span class="line">    gzip_proxied    no-cache no-store private expired auth;</span><br><span class="line">    gzip_min_length 1000;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="四、负载均衡"><a href="#四、负载均衡" class="headerlink" title="四、负载均衡"></a>四、负载均衡</h1><h2 id="HTTP负载均衡"><a href="#HTTP负载均衡" class="headerlink" title="HTTP负载均衡"></a>HTTP负载均衡</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><ol>
<li>设置一组上游服务 upstream， 默认使用round robin 算法</li>
<li>通过proxy_pass 指定上游服务组</li>
</ol>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol>
<li>round robin：通过server_weight 参数轮询</li>
<li>least_conn：发送给最少连接的上游服务，server_weight 参数作为参考</li>
<li>ip_hash：通过ip地址计算哈希值，如果需要移除一台服务，则可以设置为down，则请求将依规则发给下一台</li>
<li>hash：用户定义的哈希值进行路由</li>
<li>random：随机取出指定数量的服务，从中再根据least_conn算法路由</li>
</ol>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><ol>
<li>设置slow_start 避免服务刚恢复时，承载过多请求</li>
</ol>
<h3 id="服务失败检测"><a href="#服务失败检测" class="headerlink" title="服务失败检测"></a>服务失败检测</h3><ol>
<li>max_fails：失败达到参数设置，则nginx认为服务不可用，默认1次</li>
<li>fail_timeout：认为不可用的持续时间，即不再重试的时间，默认10s</li>
</ol>
<h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><ol>
<li>设置zone可以使nginx多个worker进程共享相同的upstream 服务组设置及相关计数</li>
</ol>
<h3 id="使用DNS"><a href="#使用DNS" class="headerlink" title="使用DNS"></a>使用DNS</h3><ol>
<li>设置resolver，valid为ttl时间，ipv6可以设置关闭</li>
<li>upstream 下各服务为域名</li>
</ol>
<h2 id="TCP、UDP负载均衡"><a href="#TCP、UDP负载均衡" class="headerlink" title="TCP、UDP负载均衡"></a>TCP、UDP负载均衡</h2><ol>
<li>与http负载均衡类似</li>
</ol>
<h2 id="反向代理时传递客户端的真实IP而非负载均衡器的IP地址"><a href="#反向代理时传递客户端的真实IP而非负载均衡器的IP地址" class="headerlink" title="反向代理时传递客户端的真实IP而非负载均衡器的IP地址"></a>反向代理时传递客户端的真实IP而非负载均衡器的IP地址</h2><ol>
<li><p>配置nginx接受代理协议，则nginx将真实客户端ip和端口存储在变量$proxy_protocol_addr，$proxy_protocol_port</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    #...</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80   proxy_protocol;</span><br><span class="line">        listen 443  ssl proxy_protocol;</span><br><span class="line">        #...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stream &#123;</span><br><span class="line">    #...</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 12345 proxy_protocol;</span><br><span class="line">        #...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>http修改当前server ip为当前实际客户端的ip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        #...</span><br><span class="line">        real_ip_header proxy_protocol;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将ip地址传递给上游服务 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    proxy_set_header X-Real-IP       $proxy_protocol_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_protocol_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将$proxy_protocol_addr添加到log_format中</p>
</li>
</ol>
<h1 id="五、安全"><a href="#五、安全" class="headerlink" title="五、安全"></a>五、安全</h1><h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>安全地协商出一份对称加密秘钥<br>RSA算法流程</p>
<ol>
<li>客户端发送client hello，客户端随机数，带上可选加密参数信息</li>
<li>服务端响应server hello，服务端随机数，已选加密参数信息</li>
<li>服务端响应certificate，发送服务器证书，server hello done</li>
<li>客户端发送证书公钥加密后的预主秘钥，客户端进一步用预主秘钥生成主秘钥，发送第一个用主密钥加密的数据</li>
<li>服务端用证书私钥解密预主秘钥，生成主密钥，握手完成</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ssl_session_cache   shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen              443 ssl;</span><br><span class="line">        server_name         www.example.com;</span><br><span class="line">        keepalive_timeout   70;</span><br><span class="line"></span><br><span class="line">        ssl_certificate     www.example.com.crt;</span><br><span class="line">        ssl_certificate_key www.example.com.key;</span><br><span class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line">        #...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="https优化"><a href="#https优化" class="headerlink" title="https优化"></a>https优化</h2><ol>
<li>使用keepalive</li>
<li>复用SSL会话参数，避免重复SSL握手</li>
</ol>
<h2 id="同一个IP支持多个https-server"><a href="#同一个IP支持多个https-server" class="headerlink" title="同一个IP支持多个https server"></a>同一个IP支持多个https server</h2><ol>
<li>因为SSL先于浏览器发送http请求，所以，服务端只提供默认证书，致使请求都指向默认server</li>
<li>最好的解决方法是，分ip部署https server</li>
<li>另外可以通过使用多个域名公共证书，同时需要TLS SNI support enabled</li>
</ol>
<h2 id="HTTP基础认证"><a href="#HTTP基础认证" class="headerlink" title="HTTP基础认证"></a>HTTP基础认证</h2><ol>
<li>auth_basic：对话框的用户区</li>
<li>auth_basic_user_file：用户密码表的文件路径</li>
<li>satisfy allow deny 设置ip限制</li>
<li>auth_request 可以指定认证location</li>
</ol>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><ol>
<li>limit_conn_zone limit_conn: 限制连接数，限制每个客户端的连接数也可以设置服务接收的连接数</li>
<li>limit_req_zone limit_req: 限制某个location下，请求的频率；burst，如果请求超出限制区，则burst为队列长度，其他请求立即返回503</li>
<li>limit_rate: 限制location下的带宽</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/07/26/nginx-1/" data-id="cjt4acf3r000hvjt9kvto3cke" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/20/http-1/" class="article-date">
  <time datetime="2018-07-20T03:21:11.000Z" itemprop="datePublished">2018-07-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP/">HTTP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/20/http-1/">《HTTP权威指南》阅读笔记一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-常见概念"><a href="#1-常见概念" class="headerlink" title="1. 常见概念"></a>1. 常见概念</h1><ol>
<li><p>MIME：Multipurpose Internet Mail Extension，电子邮件系统和HTTP用于描述标记多媒体内容</p>
</li>
<li><p>URI：统一资源标识符，可以有URL和URN两种形式</p>
</li>
<li><p>URL：协议+服务器地址+资源路径</p>
</li>
<li><p>事务：通过HTTP报文格式化数据块完成一次请求和响应</p>
</li>
</ol>
<h1 id="2-URL与资源"><a href="#2-URL与资源" class="headerlink" title="2. URL与资源"></a>2. URL与资源</h1><ol>
<li><p>大多数URL方案的语法建立在<scheme>://<user>:<password>@<host>:<port>/<path></path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></p>
</li>
<li><p>设计URL使其可以通过任意因特网协议安全传输是很重要的，有些协议如SMTP的传输方法只能使用相对较小，通用的安全字母表中的字符</p>
</li>
<li><p>URL中包含如中文等非安全字母表二进制数据或字符时，则需要进行转义</p>
</li>
<li><p>转义：百分号+字符编码的十六进制数</p>
</li>
</ol>
<h1 id="3-HTTP报文"><a href="#3-HTTP报文" class="headerlink" title="3. HTTP报文"></a>3. HTTP报文</h1><ol>
<li>组成：对报文进行描述的起始行start line \r\n作为行结束，包含属性的首部块header，包含数据的body</li>
</ol>
<h2 id="常见HTTP方法"><a href="#常见HTTP方法" class="headerlink" title="常见HTTP方法"></a>常见HTTP方法</h2><ol>
<li>GET，HEAD，POST，PUT，DELETE，TRACE(对可能经过代理服务器传送的报文进行追踪，服务响应会带上实际收到的请求原文)，OPTIONS(决定可以在服务器上执行哪些方法)</li>
</ol>
<h2 id="已定义状态码"><a href="#已定义状态码" class="headerlink" title="已定义状态码"></a>已定义状态码</h2><ol>
<li>100-101：信息提示</li>
<li>200-206：成功</li>
<li>300-305：重定向</li>
<li>400-415：客户端错误</li>
<li>500-505：服务端错误</li>
</ol>
<h1 id="4-连接管理"><a href="#4-连接管理" class="headerlink" title="4. 连接管理"></a>4. 连接管理</h1><ol>
<li>连接过程：解析主机名，dns查询ip，获取端口号，发起连接，发送请求报文，返回响应报文，关闭连接</li>
<li>HTTP事务时延：DNS查询，连接，请求，处理，响应，关闭</li>
<li>性能聚焦区域：TCP连接，TCP慢启动拥塞控制，数据聚集的Nagle算法+TCP延迟确认，TIME_WAIT时延和端口耗尽</li>
<li>并行连接：由客户端的网络带宽限制并行连接数</li>
<li>持久连接：HTTP/1.1及HTTP/1.0的增强版本 允许设备在事务处理结束时将连接保持打开状态，省去建立连接和慢启动的阶段，1.0可以通过Connection：keep-alive</li>
<li>管道化连接：HTTP/1.1允许在持久连接上使用请求管道，响应到达前将请求放入队列，不能传送非幂等请求如POST</li>
</ol>
<h1 id="5-Web服务器"><a href="#5-Web服务器" class="headerlink" title="5. Web服务器"></a>5. Web服务器</h1><ol>
<li>重定向使用场景：永久删除或临时删除的资源，负载均衡，服务器关联，规范目录名称</li>
<li>对非持久连接，发送完响应关闭服务端连接；对持久连接，需要正确计算content-length首部</li>
</ol>
<h1 id="6-代理"><a href="#6-代理" class="headerlink" title="6. 代理"></a>6. 代理</h1><ol>
<li>代理可以监视流量并对其进行修改</li>
<li>应用场景：安全防火墙，Web缓存，反向代理，内容路由器，转码，匿名</li>
<li>via： 列出了与报文途径的每个中间节点</li>
</ol>
<h1 id="7-缓存"><a href="#7-缓存" class="headerlink" title="7. 缓存"></a>7. 缓存</h1><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ol>
<li>冗余的数据传输：服务器多次传输同一份文档，增大负担，消耗带宽</li>
<li>带宽瓶颈：客户端会以路径上最慢的网速访问服务器，如果客户端能在局域网获取一份副本，将大大提升性能</li>
<li>瞬间拥塞：使web服务器过载</li>
<li>距离时延</li>
</ol>
<h2 id="缓存再验证"><a href="#缓存再验证" class="headerlink" title="缓存再验证"></a>缓存再验证</h2><ol>
<li>大部分缓存只有在客户端发起请求，且副本时间需要再次检测才会进行再验证</li>
<li>向原始服务器发送小请求，如果返回304，则缓存继续有效</li>
<li>首部：if-modified-since，只有在缓存了对象的副本后又对其进行修改，才发送此对象</li>
<li>商业代理缓存会在via首部附加额外信息以描述命中情况</li>
</ol>
<h2 id="HTTP缓存体系"><a href="#HTTP缓存体系" class="headerlink" title="HTTP缓存体系"></a>HTTP缓存体系</h2><ol>
<li>缓存存储策略：决定http响应内容是否可缓存到客户端，Cache-Control</li>
<li>缓存过期策略：决定客户端是否可以直接使用缓存数据，Expires</li>
<li>缓存对比策略：将缓存在客户端的数据标识发往服务端，服务端会查看if-modified-since等请求头，对比判断标识是否有效，如果有效则返回304</li>
</ol>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ol>
<li><a href="https://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="noopener">HTTP缓存控制小结</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24467558" target="_blank" rel="noopener">彻底弄懂 Http 缓存机制</a></li>
</ol>
<h1 id="8-网关，隧道及中继"><a href="#8-网关，隧道及中继" class="headerlink" title="8. 网关，隧道及中继"></a>8. 网关，隧道及中继</h1><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>如应用程序服务器，早期的CGI通用网关接口</p>
<h2 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h2><ol>
<li>web隧道允许用户通过http连接发送非http流量</li>
<li>使用http方法CONNECT建立http隧道</li>
<li>SSL隧道：最初的web隧道是为了通过防火墙传输SSL流量。发送CONNECT请求，返回认证请求，发送带有认证信息CONNECT请求，建立连接</li>
</ol>
<h2 id="中继"><a href="#中继" class="headerlink" title="中继"></a>中继</h2><ol>
<li>盲转发</li>
<li>无法处理Connection：keep-alive</li>
</ol>
<h1 id="9-爬虫"><a href="#9-爬虫" class="headerlink" title="9. 爬虫"></a>9. 爬虫</h1><ol>
<li>链接提取及相对链接的标准化</li>
<li>避免环路的出现</li>
<li>广度优先</li>
<li>节流</li>
<li>内容指纹</li>
</ol>
<h1 id="10-客户端识别与cookie机制"><a href="#10-客户端识别与cookie机制" class="headerlink" title="10. 客户端识别与cookie机制"></a>10. 客户端识别与cookie机制</h1><h2 id="用户识别机制"><a href="#用户识别机制" class="headerlink" title="用户识别机制"></a>用户识别机制</h2><ol>
<li>承载用户信息的HTTP首部：user-agent，cookie，referer，x-forward–for等</li>
<li>客户端IP地址：并不能精确识别客户</li>
<li>用户登录：通过www-authenticate，authorization首部</li>
<li>cookie</li>
</ol>
<h1 id="11-基本认证机制"><a href="#11-基本认证机制" class="headerlink" title="11. 基本认证机制"></a>11. 基本认证机制</h1><ol>
<li>实际使用并不安全，用户名和密码都是以明文形式传送，安全使用的唯一方式就是结合SSL</li>
</ol>
<h1 id="12-摘要认证"><a href="#12-摘要认证" class="headerlink" title="12. 摘要认证"></a>12. 摘要认证</h1><ol>
<li>用摘要保护密码，不通过网络发送密码</li>
<li>单向摘要，MD5输出的128位摘要被写成32个16进制字符</li>
<li>用随机数防止重放攻击，服务器质询时返回给客户端一个随机数，客户端在计算摘要之前要加上这个随机数</li>
</ol>
<h1 id="13-安全HTTP"><a href="#13-安全HTTP" class="headerlink" title="13. 安全HTTP"></a>13. 安全HTTP</h1><ol>
<li>对称秘钥加密：编码和解码使用相同的秘钥，流行算法：DES，RC2，RC4</li>
<li>公开秘钥加密：使用非对称秘钥，只有接收端可以用私钥解密，RSA算法</li>
<li>公开秘钥加密算法的计算可能会很慢，对称加密更快</li>
<li>两个节点间通过公开秘钥加密建立安全通信，再用安全通道产生发送临时随机对称秘钥</li>
<li>数字签名：附加在报文上的特殊加密校验码，可以证明是作者编写了这条报文，防止报文被篡改</li>
<li>数字证书：对象，过期时间，发布者，公钥，数字签名等，常见标准格式X.509 v3</li>
<li>浏览器收到服务器证书后，会对签名颁发机构进行检查</li>
<li>SSL握手：交换协议版本号，选择一个两端都了解的密码，对两端的身份进行认证，生成临时会话秘钥。</li>
<li>服务器可以要求客户端使用客户端证书，常见于组织机构内网</li>
<li>站点证书有效性：日期检测，签名颁发者可信度检测，签名检测，站点身份检测检查证书域名与访问站点域名是否一致</li>
<li>OpenSSL：SSL和TLS常见的开源实现，创建SSL本地上下文，建立443TCP连接，将SSL层附加到TCP连接，SSL握手</li>
<li>HTTPS SSL隧道协议：http通过CONNECT方法告诉代理，建立一条直接到服务端的连接，以隧道协议传输数据</li>
</ol>
<h1 id="14-实体和编码"><a href="#14-实体和编码" class="headerlink" title="14. 实体和编码"></a>14. 实体和编码</h1><ol>
<li>content-length：检测报文截尾，这对缓存服务器尤其重要；对于持久连接，客户端需要直到报文在哪里结束</li>
<li>内容编码：如果主体进行编码，content-length说明的就是编码后的长度；编码后，增加content-encoding首部用户客户端解码；客户端通过accept-encoding告知服务端可以接受的编码方式</li>
<li>实体摘要：发送方在生成初始主体时生成一个数据校验和，这样接收方就可以通过检查这个校验和捕获所有意外，相关首部content-md5</li>
<li>传输编码：改变报文数据在网络中的传输方式，解决可靠传输存在的问题：未知尺寸，用传输编码发送数据，用特别的结束脚注表明数据结束；安全性（被SSL取代），扰乱报文内容</li>
<li>Transfer-Encoding：传输编码类型，TE：告诉服务器可以使用哪些传输编码扩展</li>
<li>分块编码：把报文分割为若干个小块紧挨着发送。非持久连接，客户端读取直到服务端关闭连接。持久连接，说明每块大小，最后用0块作为主体结束的信号</li>
<li>传输编码规则：传输编码集合中要包含分块；必须最后一个作用于报文主体；不能多次作用到一个报文主体上；</li>
<li>范围请求：允许客户端只请求文档的一部分，在点对点文件共享客户端应用广泛</li>
<li>差异编码：客户端可以使用A-IM首部说明可以接受的实例操控类型，Delta-base用于计算差异的基线文档Etag，支持差异编码的服务器必须保持页面随时间变化的多个版本</li>
</ol>
<h1 id="15-国际化"><a href="#15-国际化" class="headerlink" title="15. 国际化"></a>15. 国际化</h1><ol>
<li>charset参数和content-language：告知客户端文档的字母表和语言</li>
<li>accept-language和accept-charset：告知服务端支持的字母表和语言及其优先顺序</li>
</ol>
<h1 id="16-内容协商与转码"><a href="#16-内容协商与转码" class="headerlink" title="16. 内容协商与转码"></a>16. 内容协商与转码</h1><ol>
<li>Vary：响应首部列出客户端请求首部，服务端可用这些首部选择文档</li>
<li>转码：格式转换，信息综合，内容注入</li>
</ol>
<h1 id="17-内容发布与分发"><a href="#17-内容发布与分发" class="headerlink" title="17. 内容发布与分发"></a>17. 内容发布与分发</h1><ol>
<li>CDN：内容分发网络，节点可以是web服务器，反向代理，或缓存</li>
</ol>
<h1 id="18-重定向与负载均衡"><a href="#18-重定向与负载均衡" class="headerlink" title="18. 重定向与负载均衡"></a>18. 重定向与负载均衡</h1><ol>
<li>HTTP重定向：增加时延</li>
<li>DNS重定向：返回多个ip选中的ip，缺点时DNS会缓存</li>
<li>任播寻址：地理上分散的web服务器拥有相同的ip地址，将地址广告给骨干网路由，则客户端的请求将通过最短路径路由给最近的服务器</li>
<li>IP MAC转发：交换机将分组转发到指定MAC地址</li>
<li>IP地址转发：修改目的IP地址，即NAT网络地址交换</li>
<li>代理自动配置协议PAC：配置url使用代理</li>
</ol>
<h1 id="19-日志记录"><a href="#19-日志记录" class="headerlink" title="19. 日志记录"></a>19. 日志记录</h1><ol>
<li>常用日志格式：参考nginx access.log</li>
<li>对重要的页面进行缓存清除</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/07/20/http-1/" data-id="cjt4acf4j001cvjt9dhxtm0hq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-amqp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/amqp/" class="article-date">
  <time datetime="2018-07-17T14:44:38.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/AMQP/">AMQP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/amqp/">amqp源码阅读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Python <a href="https://pypi.org/project/amqp/" target="_blank" rel="noopener">amqp</a> 是celery项目维护的一个AMQP客户端，详细的介绍可以点开链接查看。它的代码量比较小，有助于我们学习AMQP，首先我们了解一下包的目录结构。大致阅读整体代码后，我们能够了解到整体的分层设计大致如图。之后我们再深入每一层的代码实现，由底至上，学习相关的知识点。阅读完整个的源码后，我们再尝试用golang重新撸一遍实现。</p>
<p><img src="https://whales2018.github.io/pic/pic3.png" alt="amqp包目录结构"></p>
<p><img src="https://whales2018.github.io/pic/pic2.png" alt="amqp源码分层"></p>
<h2 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h2><p>这一层主要是基于TCP连接，实现带缓冲区套接字字节流的读写，协议数据报的读写</p>
<p><img src="https://whales2018.github.io/pic/pic1.png" alt="transport"></p>
<ul>
<li><p>协议无关性：socket.getaddrinfo 将返回目标地址支持的套接字信息并返回已填入相关信息的网际套接字地址结构sa，可以直接conenct。无需考虑IPv4还是IPv6</p>
</li>
<li><p>设置描述符cloexec，子进程fork之后调用exec函数成功后，会自动关闭文件描述符，避免父进程退出重启后因为端口占用无法重启：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def set_cloexec(fd, cloexec):</span><br><span class="line">    try:</span><br><span class="line">        FD_CLOEXEC = fcntl.FD_CLOEXEC</span><br><span class="line">    except AttributeError:</span><br><span class="line">        raise NotImplementedError(</span><br><span class="line">            &apos;close-on-exec flag not supported on this platform&apos;,</span><br><span class="line">        )</span><br><span class="line">    flags = fcntl.fcntl(fd, fcntl.F_GETFD)</span><br><span class="line">    if cloexec:</span><br><span class="line">        flags |= FD_CLOEXEC</span><br><span class="line">    else:</span><br><span class="line">        flags &amp;= ~FD_CLOEXEC</span><br><span class="line">    return fcntl.fcntl(fd, fcntl.F_SETFD, flags)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>套接字选项设置，详情可以参考《UNIX网络编程卷1》第7章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)</span><br><span class="line">self.sock.setsockopt(SOL_TCP, socket.TCP_NODELAY, 1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>套接字读写，TCPTransport和SSLTransport分别实现了抽象类的套接字读写方法。SSLTransport使用ssl库包裹了当前套接字并使用ssl的读写方法。读数据时，可能出现的异常</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">errno.ENOENT：recv收到对端发送的RST产生的错误</span><br><span class="line">errno.EAGAIN：如果设置成非阻塞读，没有数据可读时，返回该错误</span><br><span class="line">errno.EINTR：慢系统调用中断，常见于子进程终止时传递信号给父进程</span><br></pre></td></tr></table></figure>
<ul>
<li>协议数据报读写，从读取的方法，我们可以得到协议数据报的格式 帧类型1字节 + 2字节信道id + 4字节payload size + size字节payload + 1字节结束标志<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def read_frame(self, unpack=unpack):</span><br><span class="line">    ...</span><br><span class="line">    frame_header = read(7, True)</span><br><span class="line">    read_frame_buffer += frame_header</span><br><span class="line">    frame_type, channel, size = unpack(&apos;&gt;BHI&apos;, frame_header)</span><br><span class="line">    payload = read(size)</span><br><span class="line">    read_frame_buffer += payload</span><br><span class="line">    ch = ord(read(1))</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">def write_frame(self, frame_type, channel, payload)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据协议层"><a href="#数据协议层" class="headerlink" title="数据协议层"></a>数据协议层</h2><p>这一层主要提供了字节流与上层数据类型的转换工具AMQPReader/AMQPWriter，不同帧类型的数据报的组装和读取解析工具MethodWriter/MethodReader。我们先研究一个具体使用的场景如声明exchange_declare。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Channel(AbstractChannel):</span><br><span class="line">    def exchange_declare(self, exchange, type, passive=False, durable=False,</span><br><span class="line">                         auto_delete=True, nowait=False, arguments=None):</span><br><span class="line">                arguments = &#123;&#125; if arguments is None else arguments</span><br><span class="line">        args = AMQPWriter()</span><br><span class="line">        args.write_short(0)</span><br><span class="line">        args.write_shortstr(exchange)</span><br><span class="line">        args.write_shortstr(type)</span><br><span class="line">        args.write_bit(passive)</span><br><span class="line">        args.write_bit(durable)</span><br><span class="line">        args.write_bit(auto_delete)</span><br><span class="line">        args.write_bit(False)  # internal: deprecated</span><br><span class="line">        args.write_bit(nowait)</span><br><span class="line">        args.write_table(arguments)</span><br><span class="line">        self._send_method((40, 10), args)</span><br><span class="line"></span><br><span class="line">        if auto_delete:</span><br><span class="line">            warn(VDeprecationWarning(EXCHANGE_AUTODELETE_DEPRECATED))</span><br><span class="line"></span><br><span class="line">        if not nowait:</span><br><span class="line">            return self.wait(allowed_methods=[</span><br><span class="line">                (40, 11),  # Channel.exchange_declare_ok</span><br><span class="line">            ])</span><br></pre></td></tr></table></figure>
<p>通过AMQPWriter，将exchange_declare的参数序列化为字节流args，通过查看_send_method可以知道最后由MethodWriter.write_method执行组装发送，这里的write_frame则由底层的transport提供</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MethodWriter(object):</span><br><span class="line">    def write_method(self, channel, method_sig, args, content=None):</span><br><span class="line">        write_frame = self.dest.write_frame</span><br><span class="line">        payload = pack(&apos;&gt;HH&apos;, method_sig[0], method_sig[1]) + args</span><br><span class="line">        ...</span><br><span class="line">        write_frame(1, channel, payload)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>至此我们已经初步了解了从上层抽象的操作接口到底层字节流的转换进行通信的过程。而上述只是一个基本的包含参数的操作，对于带有消息内容的发布与接收操作，则增加两种类型：消息头部和消息实体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class MethodWriter(object):</span><br><span class="line">    def write_method(self, channel, method_sig, args, content=None):</span><br><span class="line">        ...</span><br><span class="line">        if content:</span><br><span class="line">            body = content.body</span><br><span class="line">            if isinstance(body, string):</span><br><span class="line">                coding = content.properties.get(&apos;content_encoding&apos;, None)</span><br><span class="line">                if coding is None:</span><br><span class="line">                    coding = content.properties[&apos;content_encoding&apos;] = &apos;UTF-8&apos;</span><br><span class="line"></span><br><span class="line">                body = body.encode(coding)</span><br><span class="line">            properties = content._serialize_properties()</span><br><span class="line">        ...</span><br><span class="line">        if content:</span><br><span class="line">            payload = pack(&apos;&gt;HHQ&apos;, method_sig[0], 0, len(body)) + properties</span><br><span class="line"></span><br><span class="line">            write_frame(2, channel, payload)</span><br><span class="line"></span><br><span class="line">            chunk_size = self.frame_max - 8</span><br><span class="line">            for i in range(0, len(body), chunk_size):</span><br><span class="line">                write_frame(3, channel, body[i:i + chunk_size])</span><br><span class="line">        self.bytes_sent += 1</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Message(GenericContent):</span><br><span class="line">        PROPERTIES = [</span><br><span class="line">        (&apos;content_type&apos;, &apos;shortstr&apos;),</span><br><span class="line">        (&apos;content_encoding&apos;, &apos;shortstr&apos;),</span><br><span class="line">        (&apos;application_headers&apos;, &apos;table&apos;),</span><br><span class="line">        (&apos;delivery_mode&apos;, &apos;octet&apos;),</span><br><span class="line">        (&apos;priority&apos;, &apos;octet&apos;),</span><br><span class="line">        (&apos;correlation_id&apos;, &apos;shortstr&apos;),</span><br><span class="line">        (&apos;reply_to&apos;, &apos;shortstr&apos;),</span><br><span class="line">        (&apos;expiration&apos;, &apos;shortstr&apos;),</span><br><span class="line">        (&apos;message_id&apos;, &apos;shortstr&apos;),</span><br><span class="line">        (&apos;timestamp&apos;, &apos;timestamp&apos;),</span><br><span class="line">        (&apos;type&apos;, &apos;shortstr&apos;),</span><br><span class="line">        (&apos;user_id&apos;, &apos;shortstr&apos;),</span><br><span class="line">        (&apos;app_id&apos;, &apos;shortstr&apos;),</span><br><span class="line">        (&apos;cluster_id&apos;, &apos;shortstr&apos;)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>还是同一个方法，这次我们关注frame_type为2的消息头部，从图可以看出这次需要得到两个关键信息就是消息实体的长度和序列化后的消息头的属性，消息实体的长度计算的是编码后的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class GenericContent(object):</span><br><span class="line">    def _load_properties(self, raw_bytes):</span><br><span class="line">        r = AMQPReader(raw_bytes)</span><br><span class="line">        flags = []</span><br><span class="line">        while 1:</span><br><span class="line">            flag_bits = r.read_short()</span><br><span class="line">            flags.append(flag_bits)</span><br><span class="line">            if flag_bits &amp; 1 == 0:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        shift = 0</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        for key, proptype in self.PROPERTIES:</span><br><span class="line">            if shift == 0:</span><br><span class="line">                if not flags:</span><br><span class="line">                    break</span><br><span class="line">                flag_bits, flags = flags[0], flags[1:]</span><br><span class="line">                shift = 15</span><br><span class="line">            if flag_bits &amp; (1 &lt;&lt; shift):</span><br><span class="line">                d[key] = getattr(r, &apos;read_&apos; + proptype)()</span><br><span class="line">            shift -= 1</span><br><span class="line"></span><br><span class="line">        self.properties = d</span><br><span class="line">        </span><br><span class="line">    def _serialize_properties(self):</span><br><span class="line">        shift = 15</span><br><span class="line">        flag_bits = 0</span><br><span class="line">        flags = []</span><br><span class="line">        raw_bytes = AMQPWriter()</span><br><span class="line">        for key, proptype in self.PROPERTIES:</span><br><span class="line">            val = self.properties.get(key, None)</span><br><span class="line">            if val is not None:</span><br><span class="line">                if shift == 0:</span><br><span class="line">                    flags.append(flag_bits)</span><br><span class="line">                    flag_bits = 0</span><br><span class="line">                    shift = 15</span><br><span class="line"></span><br><span class="line">                flag_bits |= (1 &lt;&lt; shift)</span><br><span class="line">                if proptype != &apos;bit&apos;:</span><br><span class="line">                    getattr(raw_bytes, &apos;write_&apos; + proptype)(val)</span><br><span class="line"></span><br><span class="line">            shift -= 1</span><br><span class="line"></span><br><span class="line">        flags.append(flag_bits)</span><br><span class="line">        result = AMQPWriter()</span><br><span class="line">        for flag_bits in flags:</span><br><span class="line">            result.write_short(flag_bits)</span><br><span class="line">        result.write(raw_bytes.getvalue())</span><br><span class="line"></span><br><span class="line">        return result.getvalue()</span><br></pre></td></tr></table></figure>
<p>消息头属性的序列化，仍然是使用AMQPWriter来对值进行转换。需要考虑三个问题，一个是如何知道消息头的属性有多少个，二是属性在字节流的对应位置，三是确定每个属性在字节流对应位置的边界。<br>写的时候通过从高位到低位设置标记位，并依次根据属性值不同类型，写入属性值转换后的数据。<br>消息实体类型的处理相对简单，如果数据太大，则分片进行多次发送，需要考虑的是接收端同一个channel需要进行等待组装完整的数据接收</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class _PartialMessage(object):</span><br><span class="line">    def add_header(self, payload):</span><br><span class="line">        ...</span><br><span class="line">    def add_payload(self, payload):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">class MethodReader(object):</span><br><span class="line">    def read_method(self):</span><br><span class="line">        self._next_method()</span><br><span class="line">        m = self._quick_get()</span><br><span class="line">        if isinstance(m, Exception):</span><br><span class="line">            raise m</span><br><span class="line">        if isinstance(m, tuple) and isinstance(m[1], AMQPError):</span><br><span class="line">            raise m[1]</span><br><span class="line">        return m</span><br><span class="line">        </span><br><span class="line">    def _next_method(self):</span><br><span class="line">        queue = self.queue</span><br><span class="line">        put = self._quick_put</span><br><span class="line">        read_frame = self.source.read_frame</span><br><span class="line">        while not queue:</span><br><span class="line">            try:</span><br><span class="line">                frame_type, channel, payload = read_frame()</span><br><span class="line">            except Exception as exc:</span><br><span class="line">                #</span><br><span class="line">                # Connection was closed?  Framing Error?</span><br><span class="line">                #</span><br><span class="line">                put(exc)</span><br><span class="line">                break</span><br><span class="line">    </span><br><span class="line">            self.bytes_recv += 1</span><br><span class="line">    </span><br><span class="line">            if frame_type not in (self.expected_types[channel], 8):</span><br><span class="line">                put((</span><br><span class="line">                    channel,</span><br><span class="line">                    UnexpectedFrame(</span><br><span class="line">                        &apos;Received frame &#123;0&#125; while expecting type: &#123;1&#125;&apos;.format(</span><br><span class="line">                            frame_type, self.expected_types[channel]))))</span><br><span class="line">            elif frame_type == 1:</span><br><span class="line">                self._process_method_frame(channel, payload)</span><br><span class="line">            elif frame_type == 2:</span><br><span class="line">                self._process_content_header(channel, payload)</span><br><span class="line">            elif frame_type == 3:</span><br><span class="line">                self._process_content_body(channel, payload)</span><br><span class="line">            elif frame_type == 8:</span><br><span class="line">                self._process_heartbeat(channel, payload)</span><br></pre></td></tr></table></figure>
<p>MethodReader提供了给上层消费者调用的read_method，内部维护一个临时队列，如果完整的数据每结束，则继续阻塞读取直到合并成完成的数据message对象，这一步临时存储和组装则由_PartialMessage完成</p>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>这一部分，通过对Connection的研究，可以将这部分分为4部分：连接管理，会话建立与关闭的状态转移，channel管理，事件驱动与分发</p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><ol>
<li>通过初始化的参数，创建Transport对象</li>
<li><p>查看连接是否存活，MSG_PEEK如果套接字有该选项，则支持从套接字缓冲区预读以此检测连接是否存活</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Connection(object):</span><br><span class="line">    def is_alive(self):</span><br><span class="line">        if HAS_MSG_PEEK:</span><br><span class="line">            sock = self.sock</span><br><span class="line">            prev = sock.gettimeout()</span><br><span class="line">            sock.settimeout(0.0001)</span><br><span class="line">            try:</span><br><span class="line">                sock.recv(1, socket.MSG_PEEK)</span><br><span class="line">            except socket.timeout:</span><br><span class="line">                pass</span><br><span class="line">            except socket.error:</span><br><span class="line">                return False</span><br><span class="line">            finally:</span><br><span class="line">                sock.settimeout(prev)</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供保持连接的心跳探活</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Connection(object):</span><br><span class="line">    def send_heartbeat(self):</span><br><span class="line">        self.transport.write_frame(8, 0, bytes())</span><br><span class="line">        </span><br><span class="line">    def heartbeat_tick(self, rate=2):</span><br><span class="line">        if not self.heartbeat:</span><br><span class="line">            return</span><br><span class="line">        </span><br><span class="line">        # 记录数据包的发送和接收数量记录</span><br><span class="line">        sent_now = self.method_writer.bytes_sent</span><br><span class="line">        recv_now = self.method_reader.bytes_recv</span><br><span class="line">        # 记录此次检查活跃的时间</span><br><span class="line">        if self.prev_sent is None or self.prev_sent != sent_now:</span><br><span class="line">            self.last_heartbeat_sent = monotonic()</span><br><span class="line">        if self.prev_recv is None or self.prev_recv != recv_now:</span><br><span class="line">            self.last_heartbeat_received = monotonic()</span><br><span class="line">        self.prev_sent, self.prev_recv = sent_now, recv_now</span><br><span class="line"></span><br><span class="line">        # 发送心跳包</span><br><span class="line">        if monotonic() &gt; self.last_heartbeat_sent + self.heartbeat:</span><br><span class="line">            self.send_heartbeat()</span><br><span class="line">            self.last_heartbeat_sent = monotonic()</span><br><span class="line"></span><br><span class="line">        # 检查失败，说明连接已经断开</span><br><span class="line">        if (self.last_heartbeat_received and</span><br><span class="line">                self.last_heartbeat_received + 2 *</span><br><span class="line">                self.heartbeat &lt; monotonic()):</span><br><span class="line">            raise ConnectionForced(&apos;Too many heartbeats missed&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接关闭，关闭transport，所有打开的channel都进行清理关闭</p>
</li>
</ol>
<h3 id="会话建立与关闭的状态转移"><a href="#会话建立与关闭的状态转移" class="headerlink" title="会话建立与关闭的状态转移"></a>会话建立与关闭的状态转移</h3><p>其状态转移过程如下图<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GRAMMAR::</span><br><span class="line"></span><br><span class="line">    connection          = open-connection *use-connection close-connection</span><br><span class="line">    open-connection     = C:protocol-header</span><br><span class="line">                          S:START C:START-OK</span><br><span class="line">                          *challenge</span><br><span class="line">                          S:TUNE C:TUNE-OK</span><br><span class="line">                          C:OPEN S:OPEN-OK</span><br><span class="line">    challenge           = S:SECURE C:SECURE-OK</span><br><span class="line">    use-connection      = *channel</span><br><span class="line">    close-connection    = C:CLOSE S:CLOSE-OK</span><br><span class="line">                        / S:CLOSE C:CLOSE-OK</span><br></pre></td></tr></table></figure></p>
<h3 id="channel-管理"><a href="#channel-管理" class="headerlink" title="channel 管理"></a>channel 管理</h3><ol>
<li>channel id 管理</li>
</ol>
<h3 id="事件驱动与分发"><a href="#事件驱动与分发" class="headerlink" title="事件驱动与分发"></a>事件驱动与分发</h3><p>Connection作为0号信道，负责该连接下的事件驱动与分发，接收server的数据报，并分发给数据报指定的channel</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/07/17/amqp/" data-id="cjt4acf4h001avjt9zf41u31l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/redis-2/" class="article-date">
  <time datetime="2018-06-30T06:47:41.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/redis-2/">Redis文档阅读笔记二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-Redis-Mass-Insertion"><a href="#1-Redis-Mass-Insertion" class="headerlink" title="1. Redis Mass Insertion"></a>1. Redis Mass Insertion</h1><ol>
<li>有时候需要将原先存有的大量数据迁移到新的redis实例,redis提供一些方案可以让这个过程更快</li>
<li>通过redis-cli一个一个操作太慢</li>
<li>通过pipeline操作,又会阻塞服务器</li>
<li>大数据量插入时,先按官网提到的协议生成对应格式的文本文件,然后使用redis-cli的管道模式批量导入</li>
</ol>
<h1 id="2-Partitioning"><a href="#2-Partitioning" class="headerlink" title="2. Partitioning"></a>2. Partitioning</h1><ol>
<li>将数据分布到不同的redis实例</li>
</ol>
<h2 id="2-1-分片策略"><a href="#2-1-分片策略" class="headerlink" title="2.1 分片策略"></a>2.1 分片策略</h2><ol>
<li>范围分片: 例如根据用户id的区间决定数据划分到哪个实例</li>
<li>hash分片: 先使用哈希函数求得哈希值,再通过取模根据结果例如介于0-3之间决定数据存储在哪个实例.少数客户端在这基础上实现了连续哈希</li>
<li>客户端分片: 在客户端就决定好读写的实例</li>
<li>代理分片: 客户端发送请求到代理,由代理决定实际的redis实例并返回响应给客户端,例如Twemproxy就应用这种模式</li>
<li>查询路由: 客户端发送请求到随机的一个redis实例,redis再转发请求到正确的节点.Redis Cluster 使用了这种模式,不同的是将客户端的连接重定向到正确的redis实例上而不是直接转发.</li>
</ol>
<h2 id="2-2-分片缺点"><a href="#2-2-分片缺点" class="headerlink" title="2.2 分片缺点"></a>2.2 分片缺点</h2><ol>
<li>分片后,不能直接对多个key一次操作</li>
<li>事务不能对多个key操作</li>
<li>像有序集合数据集被包含在一个大key中无法对内部key进行分片</li>
<li>增加操作复杂度,例如备份数据,需要整合各个实例的持久化文件</li>
<li>增加或减少容量比较复杂,Redis Cluster会重新平衡数据,当增加或者移除节点时.而使用客户端或代理分片方式则难以做到,Pre-sharding技术通过迁移实例的方式实现</li>
</ol>
<h1 id="3-Distributed-locks"><a href="#3-Distributed-locks" class="headerlink" title="3. Distributed locks"></a>3. Distributed locks</h1><ol>
<li>已经有多种库实现了分布式redis锁管理,具体<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a><h2 id="3-1-安全性和活跃度保证"><a href="#3-1-安全性和活跃度保证" class="headerlink" title="3.1 安全性和活跃度保证"></a>3.1 安全性和活跃度保证</h2></li>
<li>安全性: 互斥,同一个时刻只能有一个客户端拥有锁</li>
<li>死锁的释放: 例如当客户端锁住资源发生崩溃而其他客户端获取锁时</li>
<li>故障容错: 只要大部分redis节点存活,客户端就能进行正常的获取释放锁</li>
</ol>
<h2 id="3-2-故障转移缺陷例子"><a href="#3-2-故障转移缺陷例子" class="headerlink" title="3.2 故障转移缺陷例子"></a>3.2 故障转移缺陷例子</h2><ol>
<li>客户端A从主库获取对资源a的锁</li>
<li>对key的写入发送到从库前,主库崩溃</li>
<li>从库被提升为主库</li>
<li>客户端B从主库获取对资源a的锁,此时就违背了安全性原则</li>
</ol>
<h2 id="3-3-单实例的正确用法"><a href="#3-3-单实例的正确用法" class="headerlink" title="3.3 单实例的正确用法"></a>3.3 单实例的正确用法</h2><ol>
<li>使用setnx设置key的值,值必须全局唯一,释放锁时检查key是否存在,值是否与预期一致(第二条解释)</li>
<li>当客户端获取的锁的key带有过期时间.直接使用del最后释放锁的方式,如果过程中因为一些耗时操作导致key过期,此时其他客户端能够获取到锁,则最后del释放锁会把其他客户端的锁也释放.所以通过设置锁key的值作为签名并在最后使用del释放时做检查</li>
<li>使锁key的值唯一可以使用rc4根据具体信息生成对应随机字符串</li>
</ol>
<h2 id="3-4-Redlock-algorithm"><a href="#3-4-Redlock-algorithm" class="headerlink" title="3.4 Redlock algorithm"></a>3.4 Redlock algorithm</h2><ol>
<li>假设有5个redis独立主库</li>
<li>客户端先获取当前的时间毫秒级</li>
<li>顺序获取5个实例的锁,同样的key名和随机值.</li>
<li>客户端获取锁时,会设置一个相对锁过期时间很小的超时时间,如果一个实例获取不到锁超时则立刻获取下一个实例的</li>
<li>顺序获取实例锁时,锁的有效时间会逐渐递减,以最后获取实例的锁有效时间为准,最后每个实例锁的过期时间会是一致</li>
<li>如果已经存在N/2+1实例的锁key或者锁过期,则放弃获取所有实例的锁的操作.这就可以实现互斥原则,当一个客户端获取成功后,其他客户端可以因为没有获取到足够实例的锁而放弃</li>
<li>该算法基于假设所有机器和进程的时钟频率一致或相对于锁过期时间产生的误差可以忽略不计</li>
<li>当获取锁失败时,需要及时释放已获取的部分实例锁,可以避免需要等到key过期才能再次获取锁</li>
<li>文档对安全性和可用性进行了讨论,具体可以看文档</li>
<li>提高锁的性能可以通过使用非阻塞模式发送所有命令,再读取检查</li>
<li>需要设置持久化参数fsync=always避免断电或其他灾难后重启key丢失问题</li>
<li>算法对于断电或灾难重启后的实例不再参与现有活跃的锁.如果客户端A获取到3/5实例锁,而重启新增了一个实例,此时存在N/2+1实例的锁key条件不存在,其他客户端又可以获取锁了.解决问题的方法时,重启后保持一段不可用时间大于其他锁的过期时间.这里会引入一个问题就是如果多个实例重启,在这个不可用期间,意味着新的获取锁可能失败.</li>
<li>扩展可以考虑可重入锁的实现</li>
</ol>
<h1 id="4-Redis-Keyspace-Notifications"><a href="#4-Redis-Keyspace-Notifications" class="headerlink" title="4. Redis Keyspace Notifications"></a>4. Redis Keyspace Notifications</h1><ol>
<li>key空间报告通过发布订阅模式实现,默认不开启,可以通过配置文件开启</li>
<li>接收对key产生实际操作的事件</li>
</ol>
<h1 id="5-Secondary-indexing-with-Redis"><a href="#5-Secondary-indexing-with-Redis" class="headerlink" title="5. Secondary indexing with Redis"></a>5. Secondary indexing with Redis</h1><ol>
<li>redis主要通过key来获取数据,利用redis的一些数据结构可以创建二级索引<h2 id="5-1-有序集合的数值索引"><a href="#5-1-有序集合的数值索引" class="headerlink" title="5.1 有序集合的数值索引"></a>5.1 有序集合的数值索引</h2></li>
<li>通过有序集合的分值对数据对象进行索引</li>
<li>常见的操作为,hash结构存储数据对象集合,有序集合对数据对象创建索引</li>
<li>如果能将多维数据转为线性,则可以利用有序集合对数据进行list索引</li>
<li>两个分值一样的,则通过C函数memcmp比较</li>
</ol>
<h2 id="5-2-字典索引"><a href="#5-2-字典索引" class="headerlink" title="5.2 字典索引"></a>5.2 字典索引</h2><ol>
<li>ZRANGEBYLEX可以对值进行检索,包括或排除,可以利用在自动补全场景</li>
<li>可以再给值加上频率条件</li>
<li>考虑大小写条件时,可以按小写:频率:大写的方式存储值</li>
<li>使用组合索引,实际就是将多个字段信息组合后存储为有序集合</li>
<li>只要找到一种规则就可以合理利用ZRANGEBYLEX对数据进行查询</li>
</ol>
<h1 id="6-Replication"><a href="#6-Replication" class="headerlink" title="6. Replication"></a>6. Replication</h1><ol>
<li>主库发送将命令实时发送给从库</li>
<li>主从连接断开时会重连,并找回连接断开期间主库命令重新同步</li>
<li>如果找回断开期间部分的命令失败,则执行全部同步,具体由主库发送快照给从库,然后继续保持同步</li>
<li>从库复制异步进行,从库返回确认也是异步进行</li>
<li>如果从库落后主库,可以根据配置决定此时从库是否还可以使用旧的数据</li>
<li>主从复制的一个好处是可以避免主库持久化总是需要将数据写入磁盘,可以通过从库复制实时保存.然而需要注意的是,如果重启主库,主库数据集为空,从库同步复制主库时,从库数据也会被清空</li>
<li>建议在主从都开启持久化,或者如果不开启持久化则要避免重启机器后自动重启服务</li>
<li>每一个主库有一个replication id标识,对每个发送给从库的命令会有一个下标.如果从库断连后重连,则会告诉主库最后一个下标,并从该下标开始追赶执行命令同步主库</li>
<li>从新同步时,主库会开启一个存储进程生成RDB文件(写入磁盘),并缓存新接收的写命令.将RDB文件发送给从库,从库加载RDB文件到内存中,并接收主库缓存的命令然后继续同步</li>
<li>从库不会对key做expire操作,当主库key过期时执行del操作时发送到从库,从库执行</li>
<li>当访问从库已过期key时,因为主库的延迟操作,从库根据自身时钟做出判断报告该key不存在</li>
<li>主库执行Lua脚本时,时间被冻结,所以脚本必须同步到从库执行保证一致效果</li>
</ol>
<h1 id="7-Redis-Persistence"><a href="#7-Redis-Persistence" class="headerlink" title="7. Redis Persistence"></a>7. Redis Persistence</h1><h2 id="7-1-模式"><a href="#7-1-模式" class="headerlink" title="7.1 模式"></a>7.1 模式</h2><ol>
<li>RDB: 通过对某个时间点数据集存储为快照文件</li>
<li>AOF: 记录每一个写操作,通过重放方式初始化数据</li>
<li>可以在同一个实例中同时使用这两种模式,重启实例时,AOF模式用于从新初始化数据</li>
</ol>
<h2 id="7-2-RDB"><a href="#7-2-RDB" class="headerlink" title="7.2 RDB"></a>7.2 RDB</h2><ol>
<li>随心所欲对某个时间点的数据进行备份</li>
<li>适合用于灾难恢复</li>
<li>通过子进程完成备份,而父进程不用磁盘IO,不影响其他命令的进行</li>
<li>重启初始化数据更快</li>
<li>派生子进程,在数据集很大时会比较耗时.频繁备份对性能有一定损耗</li>
</ol>
<h2 id="7-3-AOF"><a href="#7-3-AOF" class="headerlink" title="7.3 AOF"></a>7.3 AOF</h2><ol>
<li>可以多种文件同步策略,每秒记录或每个写命令时记录,持续性更好</li>
<li>是一个只加文件,无需定位,容易修复</li>
<li>如果AOF文件太大时,redis会自动生成新的文件并切换到新的文件</li>
<li>如果不小心执行了FLUSHALL命令,只要还没有新的命令写入,停止实例.并将最后一个命令删除后重启redis就可以了</li>
</ol>
<h2 id="7-4-备份数据"><a href="#7-4-备份数据" class="headerlink" title="7.4 备份数据"></a>7.4 备份数据</h2><ol>
<li>redis会避免RDB和AOF的进程在同一时刻进行</li>
<li>建议设置定时任务生成每个小时的RDB文件放在一个文件夹和生成每天的RDB文件放在另一个文件夹</li>
<li>定时任务每次执行,清除比较老的RDB文件</li>
<li>每天转移RDB文件</li>
</ol>
<h1 id="8-Redis-Security"><a href="#8-Redis-Security" class="headerlink" title="8. Redis Security"></a>8. Redis Security</h1><ol>
<li>网络安全策略,将redis运行在虚拟化的linux实例避免直接暴露,外部无法通过防火墙连接redis,客户端通过环回地址与对应端口通信</li>
<li>安全模式: 从3.2.0版本开始,如果在配置上允许绑定所有端口,而且外部访问无需密码时会进入安全模式,只有通过环回地址的才能够正常访问,其他的客户端返回错误</li>
<li>认证功能: 密码应该设置足够长</li>
<li>数据加密: redis并不支持,不过可以再加一层SSL代理.redis推荐Spiped做对称加密</li>
<li>设置一些命令不可用</li>
<li>NoSQL注入: 注意从不可信赖来源获取可能为Lua脚本作为字符串的问题</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/redis-2/" data-id="cjt4acf4p001ivjt9oztpl3fg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/redis-1/" class="article-date">
  <time datetime="2018-06-30T06:41:04.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/redis-1/">Redis文档阅读笔记一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-Pipelining"><a href="#1-Pipelining" class="headerlink" title="1. Pipelining"></a>1. Pipelining</h1><ol>
<li>Redis是一个TCPServer,使用CS模型</li>
<li>1次请求将命令集合发送,Redis执行命令后将结果队列化后,再写入返回</li>
<li>队列化执行结果需要使用内存,如果多次大批量操作需要注意内存的使用</li>
<li>使用Redis脚本能够处理更快处理批量命令.管道无法在脚本中使用,因为使用管道时在写入之前需要返回响应给客户端(需要注意:这里个人理解可能存在偏差).反之,管道可以使用脚本</li>
</ol>
<h1 id="2-Redis-Pub-Sub"><a href="#2-Redis-Pub-Sub" class="headerlink" title="2. Redis Pub/Sub"></a>2. Redis Pub/Sub</h1><ol>
<li>发布订阅模式: 发布者发布消息到Channel,订阅者订阅Channel接收消息</li>
<li>Redis客户端一旦为订阅模式,不能接收其他命令</li>
<li>redis-cli命令行客户端时进入订阅模式之后只能通过ctrl-c取消订阅,因为此时客户端阻塞等待接收订阅消息</li>
<li>发布订阅无关于key所在空间,db10发布的,db1订阅仍能接收</li>
<li>可用模式匹配发布多个channel 和订阅多个channel</li>
</ol>
<h1 id="3-Redis-Lua-scripting"><a href="#3-Redis-Lua-scripting" class="headerlink" title="3. Redis Lua scripting"></a>3. Redis Lua scripting</h1><ol>
<li>EVAL,EVALSHA命令执行Lua脚本</li>
<li>Lua 脚本可以使用redis.call 或redis.pcall执行redis命令</li>
<li>redis.call执行遇到错误时直接抛出Lua异常结果,redis.pcall则会把异常处理成Lua table返回</li>
<li>Lua调用redis命令时把数据转成redis对应数据类型,脚本执行结果返回给客户端时Lua的数据类型转成redis对应数据类型</li>
<li>使用Lua脚本时对于浮点数最好使用字符串替代</li>
<li>如果Lua返回数组中包含nil,则数据转换终止,最终只能返回nil之前的结果</li>
<li>redis.error_reply,redis.status_reply 在Lua脚本中是比较有用的按redis数据类型返回结果的方法</li>
<li>执行Lua脚本时,其他客户端的命令和脚本将无法执行</li>
<li>redis内部缓存机制会缓存脚本,使用EVALSHA,如果redis通过匹配SHA1文摘匹配到脚本,则执行脚本,否则返回错误信息通知使用EVAL代替</li>
<li>使用SCRIPT FLUSH或重启redis实例会刷新脚本缓存</li>
<li>脚本自身会被从库复制或写入AOF文件,而不是脚本的结果命令.不过从3.2版本开始,已经可选设置复制结果命令</li>
<li>脚本不允许设置全局变量</li>
</ol>
<h1 id="4-Debugging-Lua-scripts"><a href="#4-Debugging-Lua-scripts" class="headerlink" title="4. Debugging Lua scripts"></a>4. Debugging Lua scripts</h1><ol>
<li>Redis Lua debugger默认,每一个新的Debug session是一个forked session,这意味着当脚本在debug中时,不会阻塞redis server执行其他命令,同时也意味着debug结束后会回滚脚本执行的结果</li>
<li>官网有视频详解<a href="https://redis.io/topics/ldb" target="_blank" rel="noopener">https://redis.io/topics/ldb</a></li>
</ol>
<h1 id="5-Memory-optimization"><a href="#5-Memory-optimization" class="headerlink" title="5. Memory optimization"></a>5. Memory optimization</h1><ol>
<li>通过修改redis.conf调整每一种数据类型的最大数量和最大空间</li>
<li>RDB和AOF文件兼容32位和64位,之间可以互转</li>
<li>合理利用bit和byte操作</li>
<li>尽可能使用hash结构存储数据</li>
<li>每个hash最多存储100个field是cpu和内存之间的最佳妥协</li>
<li>redis根据配置文件maxmemory分配内存</li>
<li>被删除的key实际上并不会立刻释放内存,例如在同一页中存在其他的key未被删除,需要根据峰值内存使用量限定内存使用</li>
<li>redis底层内存分配器会尽可能重复利用被删除key的内存,所以也不用太担心被删除key没有及时释放的问题</li>
<li>如果不设置maxmemory,所有的内存将可能被吃光</li>
<li>当超过最大内存限制时,导致写入时out of memory error,但不会因此导致整个机器挂掉</li>
</ol>
<h1 id="6-Expires"><a href="#6-Expires" class="headerlink" title="6. Expires"></a>6. Expires</h1><ol>
<li>过期时间只针对key不针对值</li>
<li>过期时间可以通过persist命令清除</li>
<li>通过rename重命名key,原key的过期时间仍然有效,如果由别的key rename覆盖,则该key具有别的key的特性</li>
<li>如果设置的过期时间为过去时间,则key相当于del 而不是expired</li>
<li>消极检查: 当客户端获取该key时才检查该key是否过期</li>
<li>积极检查: redis 1秒内执行10个检查过期,每次随机选取20个key,发现过期的则清除,如果发现超过25%过期,则继续下一个检查</li>
<li>过期执行删除的命令会传递给从库和AOF文件同步执行.从库不会检查key过期,当切换为主库时才会去检查</li>
</ol>
<h1 id="7-Redis-as-an-LRU-Less-Recently-Used-cache"><a href="#7-Redis-as-an-LRU-Less-Recently-Used-cache" class="headerlink" title="7. Redis as an LRU (Less Recently Used) cache"></a>7. Redis as an LRU (Less Recently Used) cache</h1><h2 id="7-1-Redis达到最大内存限制时策略"><a href="#7-1-Redis达到最大内存限制时策略" class="headerlink" title="7.1 Redis达到最大内存限制时策略"></a>7.1 Redis达到最大内存限制时策略</h2><ol>
<li>noeviction: 直接抛出异常</li>
<li>allkeys-lru: 将最近不常用的key清除腾出空间</li>
<li>volatile-lru: 将带有过期时间的最近不常用的key清除腾出空间</li>
<li>allkeys-random: 随机将key清除腾出空间</li>
<li>volatile-random: 随机将带有过期时间的key清除腾出空间</li>
<li>volatile-ttl: 将较小剩余存活时间的key清除腾出空间</li>
<li>如果不确定使用哪种策略,allkeys-lru是一个较好选择</li>
<li>volatile-lru和volatile-random比较适用于只用单个实例,混用缓存和持久key</li>
</ol>
<h2 id="7-2-近似LRU算法"><a href="#7-2-近似LRU算法" class="headerlink" title="7.2 近似LRU算法"></a>7.2 近似LRU算法</h2><ol>
<li>redis使用的并不是实际的LRU算法,而是大致评估一定样本量中选取最符合的key</li>
<li>可以通过设置配置样本量参数maxmemory-samples调节精度</li>
</ol>
<h2 id="7-3-LFU-Least-Frequently-Used"><a href="#7-3-LFU-Least-Frequently-Used" class="headerlink" title="7.3 LFU (Least Frequently Used)"></a>7.3 LFU (Least Frequently Used)</h2><ol>
<li>4.0版本以后新增了新策略,根据命中的频率决定清除哪些key</li>
<li>lfu-log-factor和lfu-decay-time是两项主要调节参数</li>
</ol>
<h1 id="8-Redis-transactions"><a href="#8-Redis-transactions" class="headerlink" title="8. Redis transactions"></a>8. Redis transactions</h1><ol>
<li>事务中的所有命令会序列化并串行化执行,在事务过程中,其他客户端发起的请求不会被处理</li>
<li>所有命令要么全部被处理或不处理(这里的处理并不表示一定执行成功),保证了原子性</li>
<li>如果使用append-only file,在发生崩溃或强制关闭redis时有可能导致执行事务中部分命令.redis重启后会检测到直接退出.使用redis-check-aof tool修复</li>
<li>MULTI开启事务,命令存储到队列,命令EXEC执行事务所有命令</li>
<li>执行EXEC检测到命令错误时,会在EXEC直接返回错误信息,并丢弃所有命令</li>
<li>执行EXEC后,部分命令执行失败,对应的命令返回错误信息,其他命令执行成功</li>
<li>redis不支持回滚:因为官方认为不需要,语法上的错误,在命令队列化时就能检测到,而编码错误导致命令执行失败redis表示不背这个锅,redis追求更简单,更快</li>
<li>使用WATCH命令实现乐观锁,如果多个客户端对同一个key进行操作并存储时,被观察的key被改变后,其他客户端对该key的修改的事务则会失败,实现了对该key的原子操作</li>
<li>需要注意的一点,当WATCH某个key之后,key过期了,那EXEC就会正常执行</li>
<li>使用WATCH可以实现对有序集合操作的原子性</li>
<li>对事务的操作在脚本中也能实现,而且脚本可以更简单更快</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/redis-1/" data-id="cjt4acf3w000qvjt97733zcjt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-6/" class="article-date">
  <time datetime="2018-06-30T06:21:03.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-6/">《高性能MySQL》阅读笔记六</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-可扩展的Mysql"><a href="#1-可扩展的Mysql" class="headerlink" title="1. 可扩展的Mysql"></a>1. 可扩展的Mysql</h1><p>可扩展性: 通过增加资源提升容量的能力</p>
<h2 id="1-1-考虑负载"><a href="#1-1-考虑负载" class="headerlink" title="1.1 考虑负载"></a>1.1 考虑负载</h2><p>容量可以简单地认为是处理负载的能力,考虑负载可从以下几个角度</p>
<ol>
<li>数据量: 很多应用从不物理删除任何数据,应用所积累的数据量是可扩展的普遍挑战</li>
<li>用户量: 更多的用户意味着更多的事务,更多的复杂查询</li>
<li>用户活跃度</li>
<li>相关数据集的大小</li>
</ol>
<h2 id="1-2-规划可扩展性"><a href="#1-2-规划可扩展性" class="headerlink" title="1.2 规划可扩展性"></a>1.2 规划可扩展性</h2><ol>
<li>估算需要承担的负载到底有多少</li>
<li>大致正确地估计日程表</li>
<li>应用的功能完成多少</li>
<li>预期的最大负载是多少</li>
<li>如果依赖系统的每个部分分担负载,某个部分失效时会发生什么</li>
</ol>
<h2 id="1-3-向上扩展-垂直扩展"><a href="#1-3-向上扩展-垂直扩展" class="headerlink" title="1.3 向上扩展(垂直扩展)"></a>1.3 向上扩展(垂直扩展)</h2><ol>
<li>单台服务器增加各种高性能硬件</li>
<li>烧钱有效的方法</li>
<li>不应该无限制向上扩展</li>
</ol>
<h2 id="1-4-向外扩展"><a href="#1-4-向外扩展" class="headerlink" title="1.4 向外扩展"></a>1.4 向外扩展</h2><ol>
<li>策略: 复制,拆分,数据分片</li>
<li>按功能拆分: 常见做法,根据功能将应用部署在不同服务器,并使用专用的数据库服务器</li>
</ol>
<h3 id="1-4-1-数据分片"><a href="#1-4-1-数据分片" class="headerlink" title="1.4.1 数据分片"></a>1.4.1 数据分片</h3><p>数据分片是目前扩展大型MySQL最通用且最成功的方法</p>
<ol>
<li>应用设计初期考虑到,后期实现就比较容易,否则很难将应用从单一数据存储转换为分片架构</li>
<li>文中举例: 通过用户id来对文章和评论进行分片,而将用户的信息保留在单个节点上</li>
<li>数据库访问抽象层,降低应用和分片数据之间通信的复杂度</li>
<li>如非必要尽量不分片</li>
<li>数据分片最大的挑战就是查找和获取数据</li>
<li>类似于表分区,选择分区键和数据分片方式是关键,具体请细查</li>
</ol>
<h2 id="1-5-通过集群扩展"><a href="#1-5-通过集群扩展" class="headerlink" title="1.5 通过集群扩展"></a>1.5 通过集群扩展</h2><ol>
<li>可以使用集群或数据库分布式技术根据场景适当解决一些问题</li>
<li>书中提到技术: NDB Cluster, Clustrix等技术</li>
</ol>
<h2 id="1-6-向内扩展"><a href="#1-6-向内扩展" class="headerlink" title="1.6 向内扩展"></a>1.6 向内扩展</h2><ol>
<li>对不再需要的数据进行归档和清理</li>
<li>需要考虑对应用的影响</li>
<li>需要考虑数据逻辑的一致性,例如清理A表历史数据时需要考虑所有关联数据的处理</li>
<li>冷热数据分离</li>
</ol>
<h2 id="1-7-负载均衡"><a href="#1-7-负载均衡" class="headerlink" title="1.7 负载均衡"></a>1.7 负载均衡</h2><h3 id="1-7-1-目的"><a href="#1-7-1-目的" class="headerlink" title="1.7.1 目的"></a>1.7.1 目的</h3><ol>
<li>可扩展性: 如读写分离时从备库读数据</li>
<li>高效性: 把更多工作分配给更好的机器</li>
<li>可用性: 使用时刻保持可用的服务器</li>
<li>透明性: 客户端无需知道服务器</li>
<li>一致性: 如果应用是有状态的,负载均衡器就应该将相关的查询指向同一个服务器</li>
</ol>
<h3 id="1-7-2-直接连接"><a href="#1-7-2-直接连接" class="headerlink" title="1.7.2 直接连接"></a>1.7.2 直接连接</h3><h4 id="1-7-2-1-复制上的读写分离"><a href="#1-7-2-1-复制上的读写分离" class="headerlink" title="1.7.2.1 复制上的读写分离"></a>1.7.2.1 复制上的读写分离</h4><ol>
<li>基于查询分离: 将不能容忍脏数据的查询分配到主库,其他分配到备库</li>
<li>基于脏数据分离: 让应用检查复制延迟,许多报表类应用使用这个策略</li>
<li>基于会话分离: 可以在会话层做一个标记,如果用户修改了数据,则一段时间内总是指向主库</li>
<li>基于版本分离: 给用户的操作增加版本号,检查版本号决定从主库还是备库读取数据</li>
</ol>
<h4 id="1-7-2-3-修改DNS名"><a href="#1-7-2-3-修改DNS名" class="headerlink" title="1.7.2.3 修改DNS名"></a>1.7.2.3 修改DNS名</h4><ol>
<li>通过变更DNS名指定的服务器实现</li>
<li>缺点很多,不建议</li>
</ol>
<h4 id="1-7-2-4-转移IP地址"><a href="#1-7-2-4-转移IP地址" class="headerlink" title="1.7.2.4 转移IP地址"></a>1.7.2.4 转移IP地址</h4><ol>
<li>在服务器之间转移虚拟地址</li>
<li>给服务器分配固定的ip地址,为每个逻辑上的服务使用一个虚拟ip地址</li>
</ol>
<h3 id="1-7-3-引入中间件"><a href="#1-7-3-引入中间件" class="headerlink" title="1.7.3 引入中间件"></a>1.7.3 引入中间件</h3><ol>
<li>负载均衡器,如HAproxy</li>
<li>负载均衡算法: 随机, 轮询,最少连接数,最快响应,哈希,权重</li>
<li>服务器池中增加或移除服务器: 在配置连接池中的服务器时,要保证有足够多未使用的容量</li>
</ol>
<h1 id="2-高可用性"><a href="#2-高可用性" class="headerlink" title="2. 高可用性"></a>2. 高可用性</h1><ol>
<li>高可用性意味着更少的宕机时间<h2 id="2-1-宕机原因"><a href="#2-1-宕机原因" class="headerlink" title="2.1 宕机原因"></a>2.1 宕机原因</h2></li>
<li>磁盘空间不足</li>
<li>糟糕的sql或者服务器bug引起</li>
<li>糟糕的表和索引设计</li>
<li>复制问题通常由于主备数据不一致导致</li>
</ol>
<h2 id="2-2-高可用性实现"><a href="#2-2-高可用性实现" class="headerlink" title="2.2 高可用性实现"></a>2.2 高可用性实现</h2><ol>
<li>衡量指标: 平均失效时间(MTBF), 平均恢复时间(MTTR)</li>
<li>避免问题: 适当的配置,监控和规范</li>
<li>保证在宕机时能快速恢复,系统制造冗余,具备故障转移能力</li>
</ol>
<h3 id="2-2-1-避免单点失效"><a href="#2-2-1-避免单点失效" class="headerlink" title="2.2.1 避免单点失效"></a>2.2.1 避免单点失效</h3><ol>
<li>通过增加冗余避免</li>
<li>共享存储或磁盘复制,如果服务器挂了,备用服务器可以挂载相同的文件系统执行需要的恢复操作</li>
<li>MySQL同步复制</li>
</ol>
<h3 id="2-2-2-故障转移和故障恢复"><a href="#2-2-2-故障转移和故障恢复" class="headerlink" title="2.2.2 故障转移和故障恢复"></a>2.2.2 故障转移和故障恢复</h3><ol>
<li>提升备库或切换角色</li>
<li>虚拟IP地址或IP接管: 当MySQL实例失效时可以将IP地址转移到另一台MySQL服务器上</li>
<li>使用中间件解决方案</li>
</ol>
<h1 id="3-备份与恢复"><a href="#3-备份与恢复" class="headerlink" title="3. 备份与恢复"></a>3. 备份与恢复</h1><h2 id="3-1-设计MySQL备份方案考虑点"><a href="#3-1-设计MySQL备份方案考虑点" class="headerlink" title="3.1 设计MySQL备份方案考虑点"></a>3.1 设计MySQL备份方案考虑点</h2><ol>
<li>在线备份还是离线备份</li>
<li>逻辑备份还是物理备份</li>
<li>非显著数据: 如二进制日志和InnoDB事务日志</li>
<li>代码: 存储过程,触发器</li>
<li>服务器配置和复制配置</li>
<li>外部配置,管理脚本</li>
<li>增量备份和差异备份</li>
<li>存储引擎和数据一致性</li>
</ol>
<h2 id="3-2-备份数据方式"><a href="#3-2-备份数据方式" class="headerlink" title="3.2 备份数据方式"></a>3.2 备份数据方式</h2><ol>
<li>文件系统中或SAN快照中直接复制数据文件</li>
<li>Percona XtraBackup 做热备份</li>
</ol>
<h2 id="3-3-InnoDB崩溃恢复"><a href="#3-3-InnoDB崩溃恢复" class="headerlink" title="3.3 InnoDB崩溃恢复"></a>3.3 InnoDB崩溃恢复</h2><ol>
<li>二级索引损坏: 使用OPTIMIZE TABLE修复损坏的二级索引,此外可以通过构建一个新表重建受影响的索引</li>
<li>聚簇索引损坏: innodb_force_recovery导出表</li>
<li>损坏系统结构: 系统结构包括事务日志等,可能需要做整个数据库的导出和还原,因为InnoDB内部绝大部分的工作可能受影响</li>
</ol>
<h1 id="4-MySQL用户工具"><a href="#4-MySQL用户工具" class="headerlink" title="4. MySQL用户工具"></a>4. MySQL用户工具</h1><p>工欲善其事,必先利其器</p>
<h2 id="4-1-接口工具"><a href="#4-1-接口工具" class="headerlink" title="4.1 接口工具"></a>4.1 接口工具</h2><ol>
<li>MySQL Workbench: 一站式的工具</li>
<li>SQLyog: 可视化工具之一</li>
</ol>
<h2 id="4-2-命令行工具集"><a href="#4-2-命令行工具集" class="headerlink" title="4.2 命令行工具集"></a>4.2 命令行工具集</h2><ol>
<li>Percona Toolkit</li>
<li>MySQL Workbench 工具集</li>
</ol>
<h2 id="4-3-SQL实用集"><a href="#4-3-SQL实用集" class="headerlink" title="4.3 SQL实用集"></a>4.3 SQL实用集</h2><ol>
<li>common_schema</li>
<li>MySQL Forge</li>
</ol>
<h2 id="4-4-监测工具"><a href="#4-4-监测工具" class="headerlink" title="4.4 监测工具"></a>4.4 监测工具</h2><ol>
<li>Nagios</li>
<li>Zabbix: 同时支持监控和指标收集的完整系统</li>
<li>Zenoss: Python写的</li>
<li>Hyperic HQ: 基于Java</li>
</ol>
<h2 id="4-5-Innotop命令行监控"><a href="#4-5-Innotop命令行监控" class="headerlink" title="4.5 Innotop命令行监控"></a>4.5 Innotop命令行监控</h2><p>主要包括以下功能</p>
<ol>
<li>事务列表</li>
<li>当前运行的查询</li>
<li>当前锁和锁等待列表</li>
<li>服务器状态和变量汇总信息</li>
<li>InnoDB内部信息</li>
<li>复制监控</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-6/" data-id="cjt4acf3n000fvjt9h45z9c60" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-5/" class="article-date">
  <time datetime="2018-06-30T06:15:53.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-5/">《高性能MySQL》阅读笔记五</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-优化服务器设置"><a href="#1-优化服务器设置" class="headerlink" title="1. 优化服务器设置"></a>1. 优化服务器设置</h1><ol>
<li>MySQL有大量的可以修改的参数,但不应该随便修改.应该将更多时间花在schema的优化,索引,查询设计上</li>
<li>配置文件路径: 通常在/etc/my.cnf</li>
<li>不建议动态修改变量,因为可能导致意外的副作用</li>
<li>通过基准测试迭代优化</li>
<li>具体配置项设置请参照官网手册,这里只提及部分</li>
</ol>
<h2 id="1-1-配置内存使用"><a href="#1-1-配置内存使用" class="headerlink" title="1.1 配置内存使用"></a>1.1 配置内存使用</h2><ol>
<li>确定可使用内存上限</li>
<li>每个连接使用多少内存,如排序缓冲和临时表</li>
<li>确定操作系统内存使用量</li>
<li>把剩下的分配给缓存,如InnoDB缓存池</li>
</ol>
<h2 id="1-2-配置MySQL的I-O行为"><a href="#1-2-配置MySQL的I-O行为" class="headerlink" title="1.2 配置MySQL的I/O行为"></a>1.2 配置MySQL的I/O行为</h2><ol>
<li>有些配置项影响如何同步数据到磁盘及如何恢复操作,这对性能影响很大,而且表现了性能和数据安全之间的平衡<h3 id="1-2-1-InnoDB-I-O配置"><a href="#1-2-1-InnoDB-I-O配置" class="headerlink" title="1.2.1 InnoDB I/O配置"></a>1.2.1 InnoDB I/O配置</h3></li>
<li>重要配置: InnoDB日志文件大小,InnoDB怎样刷新日志缓冲,InnoDB怎样执行I/O</li>
<li>InnoDB使用日志减少提交事务时开销,不用每个事务提交时把缓冲池的脏块刷到磁盘中</li>
<li>事务日志可以把随机IO变成顺序IO,同时如果发生断电,InnoDB可以重放日志恢复已经提交的事务</li>
<li>sync_binlog选项控制MySQL怎么刷新二进制日志到磁盘</li>
<li>把二进制日志放到一个带有电池保护的写缓存的RAID卷可以极大的提升性能</li>
</ol>
<h3 id="1-2-2-MyISAM的I-O配置"><a href="#1-2-2-MyISAM的I-O配置" class="headerlink" title="1.2.2 MyISAM的I/O配置"></a>1.2.2 MyISAM的I/O配置</h3><ol>
<li>因为MyISAM表每次写入都会将索引变更刷新到磁盘</li>
<li>批量操作时,通过设置delay_key_write可以延迟索引写入,可以提升性能</li>
<li>配置MyISAM怎样尝试从损坏中恢复</li>
</ol>
<h2 id="1-3-配置MySQL并发"><a href="#1-3-配置MySQL并发" class="headerlink" title="1.3 配置MySQL并发"></a>1.3 配置MySQL并发</h2><h3 id="1-3-1-InnoDB并发配置"><a href="#1-3-1-InnoDB并发配置" class="headerlink" title="1.3.1 InnoDB并发配置"></a>1.3.1 InnoDB并发配置</h3><ol>
<li>如果在InnoDB并发方面有问题,解决方案通常是升级服务器</li>
<li>innodb_thread_concurrency: 限制一次性可以有多少线程进入内核(根据实践取合适值)</li>
<li>innodb_thread_sleep_delay: 线程第一次进入内核失败等的时间,如果还不能进入则放入等待线程队列</li>
<li>innodb_commit_concurrency: 控制有多少线程可以在同一时间提交</li>
<li>使用线程池限制并发: MariaDB已经实现</li>
</ol>
<h3 id="1-3-2-MyISAM并发配置"><a href="#1-3-2-MyISAM并发配置" class="headerlink" title="1.3.2 MyISAM并发配置"></a>1.3.2 MyISAM并发配置</h3><ol>
<li>concurrency_insert: 配置MyISAM打开并发插入</li>
</ol>
<h2 id="1-4-其他"><a href="#1-4-其他" class="headerlink" title="1.4 其他"></a>1.4 其他</h2><ol>
<li>基于工作负载的配置: 利用工具分析并调整配置</li>
<li>max_connections: 保证服务器不会因应用程序激增的连接而不堪重负</li>
<li>安全和稳定的设置: 感兴趣者请自行google</li>
<li>高级InnoDB设置: 感兴趣者请自行google</li>
<li>InnoDB两个重要配置: innodb_buffer_pool_size和innodb_log_file_size</li>
</ol>
<h1 id="2-复制"><a href="#2-复制" class="headerlink" title="2. 复制"></a>2. 复制</h1><p>MySQL内建的复制功能是构建基于MySQL的大规模,高性能应用的基础.同时也是高可用性,可扩展性,灾难恢复,备份及数据仓库等工作的基础</p>
<h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>解决问题: 让一台服务器的数据与其他服务器保持同步.主库可以同步到多台备库,备库本身也可以配置为另一台服务器的主库</li>
<li>复制原理: 通过在主库上记录二进制日志,在备库重放日志的方式实现异步的数据复制</li>
<li>复制方式: 基于行的复制和基于语句的复制</li>
<li>向后兼容: 新版本只能作为老版本的备库,反之不行</li>
</ol>
<h2 id="2-2-用途"><a href="#2-2-用途" class="headerlink" title="2.2 用途"></a>2.2 用途</h2><ol>
<li>数据分布: 在不同地理位置分布数据备份,可以随意停止或开始复制.基于行比基于语句带宽压力更大</li>
<li>负载均衡: 将读操作分布到多个服务器上</li>
<li>备份: 复制是备份的一项有意义的技术补充</li>
<li>高可用性和故障切换: 避免单点失败</li>
<li>MySQL升级测试: 一种普遍做法是使用一个更高版本的MySQL作为备库保证实例升级前查询能够在备库按照预期执行</li>
</ol>
<h2 id="2-3-过程"><a href="#2-3-过程" class="headerlink" title="2.3 过程"></a>2.3 过程</h2><ol>
<li>主库把数据更改记录到二进制日志(Binary Log)</li>
<li>备库将主库上的日志复制到自己的中继日志(Relay Log)</li>
<li>备库读取中继日志中的事件,将其重放到备库数据上</li>
<li>局限: 主库上并发运行的查询在备库只能串行化执行,因为只有一个sql线程重放中继日志事件,这是很多工作负载的性能瓶颈</li>
</ol>
<h2 id="2-4-复制配置"><a href="#2-4-复制配置" class="headerlink" title="2.4 复制配置"></a>2.4 复制配置</h2><ol>
<li>在每台服务器上创建复制账号: 需要REPLICATION SLAVE权限</li>
<li>配置主库和备库: 每个服务器的ID需要唯一不能冲突</li>
<li>通知备库连接到主库并从主库复制数据</li>
<li>CHANGE MASTER TO: 指定备库连接的主库设置</li>
<li>SHOW SLAVE STATUS: 检查复制是否正确执行</li>
<li>START SLAVE: 开始复制</li>
<li>SHOW PROCESSLIST: 查看复制线程,IO线程(发送或获取日志),SQL线程(重放日志)</li>
<li>推荐配置: 开启sync_binlog</li>
</ol>
<h2 id="2-5-从另一个服务器开始复制"><a href="#2-5-从另一个服务器开始复制" class="headerlink" title="2.5 从另一个服务器开始复制"></a>2.5 从另一个服务器开始复制</h2><p>问题: 主库已经运行一段时间,用一台新安装的备库与之同步<br>保持同步条件:</p>
<ol>
<li>某个时间点的主库的数据快照</li>
<li>主库当前的二进制日志文件,和获得数据快照时在该二进制日志文件中的偏移量.通过这两个可以确定二进制日志的位置</li>
<li>从快照时间到现在的二进制日志</li>
</ol>
<p>克隆备库方法:</p>
<ol>
<li>冷备份: 关闭主库,复制数据.主库重启后会使用新的二进制文件,在备库指向这个文件的起始处</li>
<li>热备份:如果只有MyISAM,可以通过mysqlhotcopy或rsync来复制数据</li>
<li>如果只包含InnoDB: 可以使用mysqldump转储主库数据并加载到备库,然后设置相应的二进制日志坐标</li>
<li>使用快照或备份: 使用主库的快照或者备份初始化备库,然后指定二进制日志坐标</li>
<li>使用Percona Xtrabackup: 备份时不阻塞服务器操作,可以在不影响主库情况下设置备库</li>
<li>使用另外的备库: 实质就是把另外的备库当成主库进行数据克隆</li>
</ol>
<h2 id="2-6-复制的原理"><a href="#2-6-复制的原理" class="headerlink" title="2.6 复制的原理"></a>2.6 复制的原理</h2><h3 id="2-6-1-基于语句的复制"><a href="#2-6-1-基于语句的复制" class="headerlink" title="2.6.1 基于语句的复制"></a>2.6.1 基于语句的复制</h3><ol>
<li>主库会记录那些造成数据更改的查询</li>
<li>MySQL5.0之前只支持基于语句的复制</li>
<li>对于函数,存储过程和触发器在基于语句的复制模式可能存在问题</li>
<li>更新必须是串行,需要更多的锁</li>
</ol>
<h3 id="2-6-2-基于行的复制"><a href="#2-6-2-基于行的复制" class="headerlink" title="2.6.2 基于行的复制"></a>2.6.2 基于行的复制</h3><ol>
<li>将实际的数据记录在二进制日志</li>
<li>能够更高效复制数据</li>
<li>基于行的复制事件格式,对人不可读,可以使用mysqlbinlog</li>
<li>很难进行时间点恢复</li>
<li>有些操作,如全表更新(update)复制开销会很大</li>
</ol>
<h2 id="2-7-复制拓扑"><a href="#2-7-复制拓扑" class="headerlink" title="2.7 复制拓扑"></a>2.7 复制拓扑</h2><h3 id="2-7-1-基本原则"><a href="#2-7-1-基本原则" class="headerlink" title="2.7.1 基本原则"></a>2.7.1 基本原则</h3><ol>
<li>一个MySQL备库实例只能有一个主库</li>
<li>每个备库必须有一个唯一的服务器id</li>
<li>一个主库可以有多个备库</li>
<li>如果打开log_slave_update一个备库可以把其主库上的数据变化传播到其他备库</li>
</ol>
<h3 id="2-7-2-一主多备"><a href="#2-7-2-一主多备" class="headerlink" title="2.7.2 一主多备"></a>2.7.2 一主多备</h3><ol>
<li>适用于少量写和大量读,可以把读分摊到多个备库上</li>
<li>当作待用的主库</li>
<li>放到远程数据中心,用作灾难恢复</li>
<li>作为备份,培训,开发或测试服务器</li>
</ol>
<h3 id="2-7-3-双主复制"><a href="#2-7-3-双主复制" class="headerlink" title="2.7.3 双主复制"></a>2.7.3 双主复制</h3><ol>
<li>个数据库互为主库和备库</li>
<li>容易造成数据不同步</li>
<li>通常并不建议使用这种模式</li>
</ol>
<h3 id="2-7-4-主动被动的双主模式"><a href="#2-7-4-主动被动的双主模式" class="headerlink" title="2.7.4 主动被动的双主模式"></a>2.7.4 主动被动的双主模式</h3><ol>
<li>类似双主复制,把其中一台配置为只读</li>
<li>类似于创建一个热备份</li>
<li>可以用作执行读操作,备份,离线维护及升级</li>
</ol>
<h3 id="2-7-5-有备库的双主模式"><a href="#2-7-5-有备库的双主模式" class="headerlink" title="2.7.5 有备库的双主模式"></a>2.7.5 有备库的双主模式</h3><ol>
<li>双主模式下,各自有备库</li>
</ol>
<h3 id="2-7-6-主库-分发主库和备库"><a href="#2-7-6-主库-分发主库和备库" class="headerlink" title="2.7.6 主库,分发主库和备库"></a>2.7.6 主库,分发主库和备库</h3><ol>
<li>问题: 备库足够多时会对主库造成很大的负载</li>
<li>方案: 将其中部分备库当成主库,分发给更多的备库</li>
<li>通过分发主库,可以对二进制日志事件执行过滤和重写规则</li>
</ol>
<h2 id="2-8-复制管理和维护"><a href="#2-8-复制管理和维护" class="headerlink" title="2.8 复制管理和维护"></a>2.8 复制管理和维护</h2><ol>
<li>监控复制: SHOW MASTER STATUS查看主库状态, SHOW BINLOG EVENTS查看复制事件</li>
<li>测量备库延迟: 可以使用Percona Toolkit里的pt-hearbeat</li>
<li>确定主备是否一致</li>
<li>备库换主库: 难点在于获取新主库合适的二进制日志位置</li>
<li>备库提升为主库分为计划内提升和计划外提升<h3 id="2-8-1-计划内提升"><a href="#2-8-1-计划内提升" class="headerlink" title="2.8.1 计划内提升"></a>2.8.1 计划内提升</h3></li>
<li>停止向老的主库写入</li>
<li>备库赶上主库</li>
<li>备库设置为主库</li>
<li>将备库和写操作指向新主库,然后开启主库的写入</li>
</ol>
<h3 id="2-8-2-计划外提升"><a href="#2-8-2-计划外提升" class="headerlink" title="2.8.2 计划外提升"></a>2.8.2 计划外提升</h3><p>当主库崩溃时,需要提升一台备库替代</p>
<ol>
<li>确定最新的备库</li>
<li>让所有备库执行完从崩溃前主库获得的中继日志,如果未完成则更换主库,会丢失原先的日志事件</li>
<li>重新完成主备的配置</li>
</ol>
<h2 id="2-9-复制的问题和解决方案"><a href="#2-9-复制的问题和解决方案" class="headerlink" title="2.9 复制的问题和解决方案"></a>2.9 复制的问题和解决方案</h2><h3 id="2-9-1-数据损坏或丢失"><a href="#2-9-1-数据损坏或丢失" class="headerlink" title="2.9.1 数据损坏或丢失"></a>2.9.1 数据损坏或丢失</h3><ol>
<li>主库意外关闭: 主库开启sync_binlog避免事件丢失,使用Percona Toolkit中的pt-table-checksum检查主备一致性</li>
<li>备库意外关闭: 重启后观察MySQL错误日志,想方法获取备库指向主库的日志偏移量</li>
<li>主库上的二进制日志损坏: 跳过所有损坏的事件,手动找到一个完好的事件开始</li>
<li>备库上的中继日志损坏: MySQL5.5后能在崩溃后自动重新获取中继日志</li>
<li>二进制日志于InnoDB事务日志不同步: 除非备库中继日志有保存,否则自求多福</li>
</ol>
<h3 id="2-9-2-其他"><a href="#2-9-2-其他" class="headerlink" title="2.9.2 其他"></a>2.9.2 其他</h3><ol>
<li>如果使用myisam,在关闭Mysql前需要确保已经运行了stop slave,否则在服务器关闭时会kill所有正在运行的查询. </li>
<li>如果是事务型,失败的更新会在主库上回滚而且不会记录到二进制日志</li>
<li>避免混用事务和非事务: 如果备库发生死锁而主库没有,事务型会回滚而非事务型则不会造成不同步</li>
<li>主库和备库使用不同存储引擎容易导致问题</li>
<li>不唯一和未定义备库服务器id</li>
<li>避免在主库上创建备库上没有的表,因为复制可能中断</li>
<li>基于语句复制时,主库上没有安全使用临时表的方法.丢失临时表: 备库崩溃时,任何复制线程拥有的临时表都会丢失,重启备库后所有依赖临时表的语句都会失败</li>
<li>InnoDB加锁读引起的锁争用: 将大命令拆成小命令可以有效减少锁竞争</li>
<li>过大的复制延迟: 定位执行慢的语句,改善机器配置</li>
<li>其他: 查看官网手册</li>
</ol>
<h2 id="2-10-复制高级特性"><a href="#2-10-复制高级特性" class="headerlink" title="2.10 复制高级特性"></a>2.10 复制高级特性</h2><ol>
<li>半同步复制: 当提交事务,客户端收到查询结束反馈前必须保证二进制日志已经传输到至少一台备库上,主库将事务提交到磁盘上之后会增加一些延迟</li>
<li>复制心跳: 保证备库一直与主库相联系,如果出现断开的网络连接,备库会注意到丢失的心跳数据</li>
</ol>
<h2 id="2-11-其他复制技术"><a href="#2-11-其他复制技术" class="headerlink" title="2.11 其他复制技术"></a>2.11 其他复制技术</h2><ol>
<li>Percona XtraDB Cluster的同步复制</li>
<li>Tungsten</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-5/" data-id="cjt4acf4o001gvjt9g3z1gmt7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-4/" class="article-date">
  <time datetime="2018-06-30T06:00:01.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-4/">《高性能MySQL》阅读笔记四</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-查询性能优化"><a href="#1-查询性能优化" class="headerlink" title="1. 查询性能优化"></a>1. 查询性能优化</h1><h2 id="1-1-优化数据访问"><a href="#1-1-优化数据访问" class="headerlink" title="1.1 优化数据访问"></a>1.1 优化数据访问</h2><ol>
<li>检查是否检索大量超过需要的数据.是否访问太多行或太多列,增加网络开销,消耗cpu和内存资源</li>
<li>检查服务器层是否在分析大量超过需要的数据行</li>
</ol>
<h2 id="1-2-重构查询的方式"><a href="#1-2-重构查询的方式" class="headerlink" title="1.2 重构查询的方式"></a>1.2 重构查询的方式</h2><h3 id="1-2-1-切分查询"><a href="#1-2-1-切分查询" class="headerlink" title="1.2.1 切分查询"></a>1.2.1 切分查询</h3><ol>
<li>有时对于一个大查询我们需要分而治之,切分成小查询每次只完成一部分</li>
</ol>
<h3 id="1-2-2-分解关联查询"><a href="#1-2-2-分解关联查询" class="headerlink" title="1.2.2 分解关联查询"></a>1.2.2 分解关联查询</h3><ol>
<li>缓存效率更高: 方便缓存单表查询结果</li>
<li>执行单个查询可以减少锁的竞争</li>
<li>在应用层做关联，更容易对数据库进行拆分，更容易做到高性能和可扩展</li>
<li>使用in　代替关联查询可能比随机的关联要高效</li>
<li>可以减少冗余记录的查询</li>
</ol>
<h2 id="1-3-查询执行的基础"><a href="#1-3-查询执行的基础" class="headerlink" title="1.3 查询执行的基础"></a>1.3 查询执行的基础</h2><h3 id="1-3-1-查询流程"><a href="#1-3-1-查询流程" class="headerlink" title="1.3.1 查询流程"></a>1.3.1 查询流程</h3><ol>
<li>先检查缓存</li>
<li>sql解析,预处理,优化器生成相应的执行计划</li>
<li>调用存储引擎的api执行查询</li>
</ol>
<h3 id="1-3-2-通信协议"><a href="#1-3-2-通信协议" class="headerlink" title="1.3.2 通信协议"></a>1.3.2 通信协议</h3><ol>
<li>半双工,任何一时刻要么是服务器向客户端发送数据,要么是客户端向服务端发送数据</li>
<li>客户端从服务器获取数据时,实际是MySQL向客户端推送数据的过程</li>
</ol>
<h3 id="1-3-3-查询状态"><a href="#1-3-3-查询状态" class="headerlink" title="1.3.3 查询状态"></a>1.3.3 查询状态</h3><ol>
<li>Ｓleep: 线程正在等待客户端发送新的请求</li>
<li>Query: 线程正在执行查询或者正在将结果发送给客户端</li>
<li>Locked: 服务器层,线程正在等待表锁</li>
<li>Analyzing and statistics: 线程正在收集存储引擎统计信息,并生成查询的执行计划</li>
<li>Copying to tmp table: 线程正在执行查询,并且将结果集复制到一个临时表中.常见group by或文件排序操作</li>
<li>Sorting result: 线程正在对结果进行排序</li>
<li>Sending data: 线程可能在多个状态之间传送数据或在生成结果集或向客户端返回数据</li>
</ol>
<h3 id="1-3-4-查询优化"><a href="#1-3-4-查询优化" class="headerlink" title="1.3.4 查询优化"></a>1.3.4 查询优化</h3><h4 id="1-3-4-1-语法解析器和预处理"><a href="#1-3-4-1-语法解析器和预处理" class="headerlink" title="1.3.4.1 语法解析器和预处理"></a>1.3.4.1 语法解析器和预处理</h4><ol>
<li>通过关键字将sql语句进行解析,生成对应的解析树</li>
<li>解析器使用语法规则验证和解析查询</li>
<li>预处理器进一步检查解析树是否合法,验证权限</li>
</ol>
<h4 id="1-3-4-2-查询优化器"><a href="#1-3-4-2-查询优化器" class="headerlink" title="1.3.4.2 查询优化器"></a>1.3.4.2 查询优化器</h4><ol>
<li>一条查询可以有多种执行方式,优化器找到其中最好的执行计划,MySQL使用基于成本的优化器</li>
<li>优化类型</li>
<li>重新定义关联表的顺序</li>
<li>外联结转化成内连接</li>
<li>使用等价变换规则</li>
<li>优化count, min, max函数</li>
<li>预估并转化为常数表达式</li>
<li>覆盖索引扫描</li>
<li>子查询优化</li>
<li>提前终止查询,如limit</li>
<li>等值传播</li>
<li>In优化</li>
</ol>
<h4 id="1-3-4-3-关联查询"><a href="#1-3-4-3-关联查询" class="headerlink" title="1.3.4.3 关联查询"></a>1.3.4.3 关联查询</h4><ol>
<li>嵌套循环: 先在一个表中循环取出单条数据,然后再嵌套循环到下一个表中寻找匹配的行,如果最后一个联表无法找到更多的行,则返回上一层次关联表</li>
<li>UNION查询和子查询时都会将临时结果存放到一个临时表中</li>
</ol>
<h4 id="1-3-4-4-执行计划"><a href="#1-3-4-4-执行计划" class="headerlink" title="1.3.4.4 执行计划"></a>1.3.4.4 执行计划</h4><ol>
<li>MySQL生成一棵指令树,通过存储引擎执行完成并返回结果</li>
</ol>
<h4 id="1-3-4-5-排序优化"><a href="#1-3-4-5-排序优化" class="headerlink" title="1.3.4.5 排序优化"></a>1.3.4.5 排序优化</h4><ol>
<li>排序是一个成本很高的操作</li>
<li>MySQL排序: 如果数据量小,则在内存中进行; 数据量大则先分块再排序再合并</li>
<li>MySQL4.1后使用单次传输排序: 先读取查询所需要的所有列,再根据给定列排序</li>
</ol>
<h4 id="1-3-4-6-查询执行引擎"><a href="#1-3-4-6-查询执行引擎" class="headerlink" title="1.3.4.6 查询执行引擎"></a>1.3.4.6 查询执行引擎</h4><ol>
<li>根据执行计划的指令逐步执行</li>
</ol>
<h4 id="1-3-4-7-返回结果给客户端"><a href="#1-3-4-7-返回结果给客户端" class="headerlink" title="1.3.4.7 返回结果给客户端"></a>1.3.4.7 返回结果给客户端</h4><ol>
<li>如果查询可以缓存,则缓存在这个阶段进行</li>
<li>返回结果的过程是一个增量逐步返回的过程,一旦开始生成第一条结果时就可以开始向客户端返回结果集</li>
</ol>
<h2 id="1-4-查询优化器的局限"><a href="#1-4-查询优化器的局限" class="headerlink" title="1.4 查询优化器的局限"></a>1.4 查询优化器的局限</h2><ol>
<li>子查询相对糟糕(不是绝对),如子查询用in</li>
<li>联表查询与子查询根据场景不同有不同优势</li>
<li>MySQL无法将限制条件下推到子查询</li>
<li>索引合并优化</li>
<li>MySQL无法利用多核特性并行执行查询</li>
<li>MySQL并不支持哈希关联, MariaDB已经实现了真正的哈希关联  </li>
<li>松散索引扫描,无法按照不连续的方式扫描一个索引</li>
<li>最大值最小值函数的优化一般</li>
<li>不允许同一张表上同时查询和更新, 如update set 等于 select 自己.解决方法,可以通过关联临时表</li>
</ol>
<h2 id="1-5-查询优化器的提示"><a href="#1-5-查询优化器的提示" class="headerlink" title="1.5 查询优化器的提示"></a>1.5 查询优化器的提示</h2><ol>
<li>设置查询优化器参数,可以阅读官方手册</li>
<li>一般除非需要,修改查询优化器参数会提高维护成本</li>
</ol>
<h2 id="1-6-优化特定类型的查询"><a href="#1-6-优化特定类型的查询" class="headerlink" title="1.6 优化特定类型的查询"></a>1.6 优化特定类型的查询</h2><ol>
<li>关联查询: on的列加索引; 使用group by和order by 只使用一个表的列可以利用索引</li>
<li>优化LIMIT分页: 尽量使用覆盖索引</li>
<li>子查询: 尽量使用关联查询替换</li>
<li>静态查询分析: Percona Toolkit中的pt-query-advisor能解析查询日志,分析查询模式</li>
<li>使用用户自定义变量: 无法使用查询缓存,可能被优化器优化掉</li>
</ol>
<h1 id="2-MySQL高级特性"><a href="#2-MySQL高级特性" class="headerlink" title="2. MySQL高级特性"></a>2. MySQL高级特性</h1><h2 id="2-1-分区表"><a href="#2-1-分区表" class="headerlink" title="2.1 分区表"></a>2.1 分区表</h2><h3 id="2-1-1-应用"><a href="#2-1-1-应用" class="headerlink" title="2.1.1 应用"></a>2.1.1 应用</h3><ol>
<li>表非常大无法全部放在内存中,或者只在表的最后部分有热点数据其他均是历史数据</li>
<li>分区表的数据更容易维护</li>
<li>分区表的数据可以分布在不同的物理设备上</li>
<li>使用分区表避免某些瓶颈,如InnoDB单个索引的互斥访问</li>
<li>备份和恢复独立分区,对于大数据集效果较好</li>
</ol>
<h3 id="2-1-2限制"><a href="#2-1-2限制" class="headerlink" title="2.1.2限制"></a>2.1.2限制</h3><ol>
<li>一个表最多1024个分区</li>
<li>分区表达式必须是整数或返回整数的表达式</li>
<li>如果分区字段有主键或唯一索引列,那么所有主键列和唯一索引都必须包含进来</li>
<li>分区表中无法使用外键约束</li>
</ol>
<h3 id="2-1-3-原理"><a href="#2-1-3-原理" class="headerlink" title="2.1.3 原理"></a>2.1.3 原理</h3><ol>
<li>分区表由多个相关的底层表实现,存储引擎管理它们跟管理普通表一样</li>
<li>select 查询: 分区层打开并锁住所有底层表,优化器判断是否过滤分区,在调用存储引擎api访问各个分区数据</li>
<li>insert: 分区层打开并锁住所有底层表,确定分区,写入</li>
<li>delete: 分区层打开并锁住所有底层表,确定数据所在分区,删除</li>
<li>update: 分区层打开并锁住所有底层表,确定分区,取出数据,更新,确定分区,写入</li>
<li>打开并锁住所有底层表: 如果存储引擎实现行级锁如InnoDB,则会在分区层释放表锁</li>
</ol>
<h3 id="2-1-4-分区表类型"><a href="#2-1-4-分区表类型" class="headerlink" title="2.1.4 分区表类型"></a>2.1.4 分区表类型</h3><ol>
<li>根据范围进行分区: 每个分区储存落在某个范围的记录</li>
<li>根据键值进行分区,减少InnoDB互斥量竞争</li>
<li>使用数学模函数进行分区,然后将数据轮询放入不同的分区,适用于只想保留几天的数据</li>
</ol>
<h3 id="2-1-5-使用"><a href="#2-1-5-使用" class="headerlink" title="2.1.5 使用"></a>2.1.5 使用</h3><ol>
<li>问题回顾:数据量很大时,除非是索引覆盖查询,否则数据库需要根据索引扫描回表查询,产生大量的随机IO,数据库响应时间很大</li>
<li>全量扫描数据不要索引,根据分区定位数据位置</li>
<li>索引数据,分离热点. 将热点数据单独放在一个分区</li>
<li>NULL值会使分区过滤无效: 分区表达式接收NULL值并将其放到第一个分区导致查询时多查分区.解决方法:创建第一个无用分区存放NULL值数据</li>
<li>分区列和索引列不匹配,查询无法进行分区过滤</li>
<li>选择分区成本高,插入大量数据时都需要扫描分区定义找到分区</li>
<li>打开并锁住所有底层表的成本可能很高</li>
<li>维护分区的成本很高,同alter一样创建临时表然后拷贝数据</li>
<li>所有分区都必须使用相同的存储引擎</li>
</ol>
<h3 id="2-1-6-查询优化"><a href="#2-1-6-查询优化" class="headerlink" title="2.1.6 查询优化"></a>2.1.6 查询优化</h3><ol>
<li>在where条件带入分区列</li>
<li>创建分区时可以使用表达式,但是查询时只能在使用分区列本身进行比较时才能过滤分区,而不能根据表达式的值过滤分区</li>
</ol>
<h2 id="2-2-视图"><a href="#2-2-视图" class="headerlink" title="2.2 视图"></a>2.2 视图</h2><p>视图本身是一个虚拟表,不存放任何数据,不能对视图创建触发器</p>
<h3 id="2-2-1-算法"><a href="#2-2-1-算法" class="headerlink" title="2.2.1 算法"></a>2.2.1 算法</h3><ol>
<li>合并算法: 将存放的视图sql和用户发起的查询sql合并后执行</li>
<li>临时表算法: 由存放的视图sql先创建临时表后根据用户的查询sql查询返回</li>
</ol>
<h3 id="2-2-2-可更新视图"><a href="#2-2-2-可更新视图" class="headerlink" title="2.2.2 可更新视图"></a>2.2.2 可更新视图</h3><ol>
<li>可以通过更新视图更新相关表, 所有临时表算法实现的视图都无法更新</li>
</ol>
<h3 id="2-2-3-视图对性能的影响"><a href="#2-2-3-视图对性能的影响" class="headerlink" title="2.2.3 视图对性能的影响"></a>2.2.3 视图对性能的影响</h3><ol>
<li>一般情况视图不能提升性能,在某些情况下可以帮助提升性能,需要做比较详细的测试</li>
<li>视图还可以实现基于列的权限控制不用真正创建列权限</li>
</ol>
<h3 id="2-2-4-视图的限制"><a href="#2-2-4-视图的限制" class="headerlink" title="2.2.4 视图的限制"></a>2.2.4 视图的限制</h3><ol>
<li>不保存视图定义的原始sql语句</li>
<li>查看视图创建的语句,可以通过使用视图的.frm文件的最后一行获取一些信息</li>
</ol>
<h2 id="2-3-外键约束"><a href="#2-3-外键约束" class="headerlink" title="2.3 外键约束"></a>2.3 外键约束</h2><ol>
<li>InnoDB强制外键使用索引</li>
<li>查询需要额外访问一些表,需要额外的锁容易导致一些死锁</li>
<li>如果使用外键做约束,通常在应用程序里实现会更好</li>
</ol>
<h2 id="2-4-内部存储代码"><a href="#2-4-内部存储代码" class="headerlink" title="2.4 内部存储代码"></a>2.4 内部存储代码</h2><h3 id="2-4-1-优点"><a href="#2-4-1-优点" class="headerlink" title="2.4.1 优点"></a>2.4.1 优点</h3><ol>
<li>离数据最近,节省带宽和网络延迟</li>
<li>帮助提升安全性,应用程序可以通过存储过程访问那些没有权限的表</li>
<li>服务器端可以缓存存储过程的执行计划</li>
<li>维护方便,便于分工</li>
</ol>
<h3 id="2-4-2-缺点"><a href="#2-4-2-缺点" class="headerlink" title="2.4.2 缺点"></a>2.4.2 缺点</h3><ol>
<li>调试困难,难以定位问题</li>
<li>存储代码效率相对差</li>
<li>增加维护复杂性,存储过程会给数据库服务器增加额外压力</li>
<li>存在安全隐患,没有什么选项可以控制存储程序的资源消耗,所以一个小错误可能直接把服务器拖死</li>
</ol>
<h3 id="2-4-3-存储过程和函数"><a href="#2-4-3-存储过程和函数" class="headerlink" title="2.4.3 存储过程和函数"></a>2.4.3 存储过程和函数</h3><ol>
<li>优化器无法评估存储函数的执行成本</li>
<li>每个连接都有独立的存储过程的执行计划缓存,多个连接调用同一个存储过程会浪费缓存空间反复缓存同样的执行计划</li>
</ol>
<h3 id="2-4-4-触发器"><a href="#2-4-4-触发器" class="headerlink" title="2.4.4 触发器"></a>2.4.4 触发器</h3><ol>
<li>每个表的每个事件只能一个</li>
<li>MySQL只支持基于行的触发,如果变更的数据集非常庞大的化效率会很低</li>
<li>触发器的问题很难排查</li>
<li>可能导致死锁和锁等待</li>
<li>实现一些约束,系统维护任务及更新反范式化数据的时候会比较有用</li>
</ol>
<h3 id="2-4-5-事件"><a href="#2-4-5-事件" class="headerlink" title="2.4.5 事件"></a>2.4.5 事件</h3><ol>
<li>类似Linux的定时任务</li>
</ol>
<h2 id="2-5-游标"><a href="#2-5-游标" class="headerlink" title="2.5 游标"></a>2.5 游标</h2><ol>
<li>MySQL在服务器端提供只读的,单向的游标</li>
<li>一个存储过程中可以有多个游标,也可以嵌套</li>
</ol>
<h2 id="2-6-绑定变量"><a href="#2-6-绑定变量" class="headerlink" title="2.6 绑定变量"></a>2.6 绑定变量</h2><ol>
<li>创建一个绑定变量sql时客户端向服务器发送了一个sql语句原型</li>
<li>服务器端解析并存储这个sql语句的部分执行计划返回客户端一个sql语句处理句柄</li>
<li>可以使用问号作为sql的占位,在使用sql接口执行时赋予变量值</li>
</ol>
<h2 id="2-7-插件"><a href="#2-7-插件" class="headerlink" title="2.7 插件"></a>2.7 插件</h2><ol>
<li>存储过程插件</li>
<li>后台插件: 如Percona Server中包含的Handler-Socket</li>
<li>INFORMATION_SCHEMA插件</li>
<li>全文解析插件: 可以对文档进行分词处理</li>
<li>审计插件: 可以用作记录事件日志</li>
<li>认证插件: 扩展认证功能</li>
</ol>
<h2 id="2-8-字符集和校对"><a href="#2-8-字符集和校对" class="headerlink" title="2.8 字符集和校对"></a>2.8 字符集和校对</h2><ol>
<li>字符集是指一种从二进制编码到某类字符符号的映射</li>
<li>校对是指一组用于某个字符集的排序规则<h3 id="2-8-1-创建对象时的默认设置"><a href="#2-8-1-创建对象时的默认设置" class="headerlink" title="2.8.1 创建对象时的默认设置"></a>2.8.1 创建对象时的默认设置</h3></li>
<li>服务器,数据库,表都有默认的字符集和校对规则,这是一个逐层继承的默认设置</li>
<li>创建数据库时根据character_set_server设置来设定默认字符集</li>
</ol>
<h3 id="2-8-2-服务器和客户端通信设置"><a href="#2-8-2-服务器和客户端通信设置" class="headerlink" title="2.8.2 服务器和客户端通信设置"></a>2.8.2 服务器和客户端通信设置</h3><ol>
<li>服务端总是假设客户端按照character_set_client设置的字符来传输数据和sql语句</li>
<li>服务器端收到sql语句后根据character_set_connection转换成字符串</li>
<li>服务器端返回数据时会将其转换为character_set_result</li>
</ol>
<h3 id="2-8-3-选择字符集和校对规则"><a href="#2-8-3-选择字符集和校对规则" class="headerlink" title="2.8.3 选择字符集和校对规则"></a>2.8.3 选择字符集和校对规则</h3><ol>
<li>极简原则: 先为服务器选择合理的字符集在根据实际情况让某些列选择合适的字符集</li>
</ol>
<h3 id="2-8-4-对查询的影响"><a href="#2-8-4-对查询的影响" class="headerlink" title="2.8.4 对查询的影响"></a>2.8.4 对查询的影响</h3><ol>
<li>不同字符集和校对规则之间的转换会带来额外的开销</li>
<li>排序查询要求的字符集与服务器数据的字符集相同时才能利用索引进行排序</li>
<li>当两个字符集不同列关联两个表时,MySQL会尝试转换其中一个列的字符集</li>
</ol>
<h2 id="2-9-全文索引"><a href="#2-9-全文索引" class="headerlink" title="2.9 全文索引"></a>2.9 全文索引</h2><ol>
<li>自然语言的全文索引: 相关度是基于匹配的关键词个数及关键词在文档中出现的次数,整个索引中出现次数越少的词语匹配的相关度越高</li>
<li>布尔全文索引: 只有MyISAM才能使用</li>
<li>平时没接触过,有兴趣者请自行google</li>
</ol>
<h2 id="2-10-分布式XA事务"><a href="#2-10-分布式XA事务" class="headerlink" title="2.10 分布式XA事务"></a>2.10 分布式XA事务</h2><ol>
<li>事务协调器保证所有事务参与者完成工作,通知所有事务提交</li>
<li>内部XA事务: 存储引擎提交的同时,需要将提交的信息写入二进制日志</li>
<li>外部XA事务: XA事务是一种在多个服务器之间同步数据的方法,如果由于不能使用MySQL本身的复制或者性能并不是瓶颈可以尝试使用</li>
</ol>
<h2 id="2-11-查询缓存"><a href="#2-11-查询缓存" class="headerlink" title="2.11 查询缓存"></a>2.11 查询缓存</h2><ol>
<li>查询缓存系统会跟踪查询中涉及的每个表,如果表发生变化则缓存数据失效</li>
<li>缓存存放在一个引用表中,通过一个哈希值引用,哈希值包括查询本身,查询数据库等信息</li>
<li>当sql语句和客户端发送过来的其他原始信息,任何字符上的不同都会导致缓存不命中</li>
<li>打开查询缓存对读和写都会带来额外的消耗</li>
<li>InnoDB事务修改表时,会将这个表对应的查询缓存都设置失效</li>
<li>查询缓存被发现是一个影响服务器扩展性的因素</li>
<li>如果缓存了大量的查询结果,那么失效操作可能会造成系统僵死.因为靠一个全局锁保护,所有该操作都要等锁</li>
<li>减少碎片, 选择合适的query_cache_min_res_unit可以减少内存浪费</li>
<li>对于写密集型的应用,直接禁用更好</li>
<li>高并发环境也不适合.只有明确缓存的好处才使用</li>
<li>查询缓存的替代方案: 客户端缓存</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-4/" data-id="cjt4acf4n001fvjt9itt68pls" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/30/mysql-3/" class="article-date">
  <time datetime="2018-06-30T05:53:23.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/30/mysql-3/">《高性能MySQL》阅读笔记三</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-schema与数据类型优化"><a href="#1-schema与数据类型优化" class="headerlink" title="1. schema与数据类型优化"></a>1. schema与数据类型优化</h1><h2 id="1-1-数据类型选择"><a href="#1-1-数据类型选择" class="headerlink" title="1.1 数据类型选择"></a>1.1 数据类型选择</h2><p>更小: 选择不超过需求范围的最小类型</p>
<p>更简单</p>
<p>避免使用Null: 含有Null列会使索引,索引统计和值更为复杂</p>
<p>分配空间: 根据实际需要分配.使用内存临时表或操作时会比较糟糕</p>
<p>特殊类型:书中举例,ip地址应该用无符号整数存储,MySQL提供inet_aton, inet_ntoa方法转换</p>
<h2 id="1-2-schema-设计陷阱"><a href="#1-2-schema-设计陷阱" class="headerlink" title="1.2 schema 设计陷阱"></a>1.2 schema 设计陷阱</h2><ol>
<li><p>太多列,存储引擎api需要在服务器层和存储引擎层通过行缓冲格式拷贝数据,然后解码.转换代价依赖于列的数量</p>
</li>
<li><p>太多的关联,单个查询最好在12个表以内</p>
</li>
<li><p>最好不用枚举enum</p>
</li>
<li><p>可以使用其他”空值”替代Null</p>
</li>
</ol>
<h2 id="1-3-范式和反范式"><a href="#1-3-范式和反范式" class="headerlink" title="1.3 范式和反范式"></a>1.3 范式和反范式</h2><ol>
<li><p>范式化: 每个事实数据只出现一次</p>
</li>
<li><p>反范式化: 信息是冗余的</p>
</li>
<li><p>第一范式1NF: 关系中的每个属性都不可再分</p>
</li>
<li><p>第二范式2NF: 每个表中的非主属性完全依赖于码(例如主键, 可以唯一决定属性集合)</p>
</li>
<li><p>第三范式3NF: 消除非主属性之间的依赖关系，只保留非主属性与码的依赖关系</p>
</li>
<li><p>范式化优点: 更新操作更快,占用空间更小</p>
</li>
<li><p>范式化缺点: 表的关联查询更多</p>
</li>
<li><p>混用范式和反范式: 从父表冗余一些数据到子表有利于排序, 缓存衍生值减少子查询计算</p>
</li>
</ol>
<h2 id="1-4-缓存表和汇总表"><a href="#1-4-缓存表和汇总表" class="headerlink" title="1.4 缓存表和汇总表"></a>1.4 缓存表和汇总表</h2><p>业务上有时需要一张完全独立的汇总表或缓存表主要用于满足检索的需求</p>
<ol>
<li><p>Flexviews实现物化视图,可以增量重新计算物化视图的内容</p>
</li>
<li><p>计数器表: 如果需要在表中保存计数器,更新计数器时,会有全局的互斥锁.要获的高并发更新的性能,可以将计数器保存在多行,每次随机选择一个进行更新</p>
</li>
</ol>
<h2 id="1-5-修改表结构"><a href="#1-5-修改表结构" class="headerlink" title="1.5 修改表结构"></a>1.5 修改表结构</h2><ol>
<li><p>大部分的alter table操作将导致服务中断</p>
</li>
<li><p>所有的modify column 操作都将导致表重建</p>
</li>
<li><p>可以新建一个.frm文件为修改后的表结构,替换原来的.frm文件避免表重建</p>
</li>
</ol>
<h1 id="2-创建高性能的索引"><a href="#2-创建高性能的索引" class="headerlink" title="2. 创建高性能的索引"></a>2. 创建高性能的索引</h1><p>索引是存储引擎用于快速查找记录的数据结构</p>
<h2 id="2-1-索引基础"><a href="#2-1-索引基础" class="headerlink" title="2.1 索引基础"></a>2.1 索引基础</h2><p>MySQL中,存储引擎先在索引中找到对应值根据匹配的索引记录找到对应的数据行.索引在存储引擎层实现</p>
<h3 id="2-1-1-B-Tree索引"><a href="#2-1-1-B-Tree索引" class="headerlink" title="2.1.1 B-Tree索引"></a>2.1.1 B-Tree索引</h3><ol>
<li><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构. </p>
</li>
<li><p>InnoDB使用B+Tree, NDB集群存储引擎实际使用T-Tree. 索引对多个值的排序一句是根据表定义索引时列的顺序.</p>
</li>
<li><p>索引对如下类型的查询有效</p>
</li>
<li><p>全值匹配</p>
</li>
<li><p>匹配最左前缀,只使用索引第一列</p>
</li>
<li><p>匹配列前缀: 只匹配某一列值的开头部分</p>
</li>
<li><p>匹配范围值</p>
</li>
<li><p>精确匹配某一列并范围匹配另外一列</p>
</li>
<li><p>只访问索引的查询: 查询只需要访问索引无需访问数据行(覆盖扫描)</p>
</li>
<li><p>限制</p>
</li>
<li><p>如果不是按照索引的最左列开始,则无法使用索引</p>
</li>
<li><p>不能跳过索引中的列,即定义索引(a,b,c),则使用a,c查询条件时,只能使用索引第一列</p>
</li>
<li><p>如果查询中有某个列的范围查询,则右边所有的列都无法使用索引优化查找</p>
</li>
</ol>
<h3 id="2-1-2-哈希索引"><a href="#2-1-2-哈希索引" class="headerlink" title="2.1.2 哈希索引"></a>2.1.2 哈希索引</h3><ol>
<li><p>对于每一行数据,存储引擎会对索引列计算一个哈希码.索引包含哈希码和行指针</p>
</li>
<li><p>MySQL中只有Memory存储引擎支持</p>
</li>
<li><p>限制</p>
</li>
<li><p>不能使用索引中的值避免读取行</p>
</li>
<li><p>无法用于排序</p>
</li>
<li><p>不支持部分索引列匹配查找</p>
</li>
<li><p>不支持范围查询</p>
</li>
<li><p>出现哈希冲突时会扫表</p>
</li>
</ol>
<h3 id="2-1-3-伪哈希索引"><a href="#2-1-3-伪哈希索引" class="headerlink" title="2.1.3 伪哈希索引"></a>2.1.3 伪哈希索引</h3><ol>
<li><p>应用: 当存储引擎不支持哈希索引,在B-Tree基础上使用哈希值索引查找</p>
</li>
<li><p>场景: 需要存储大量的url并根据url进行搜索查找</p>
</li>
<li><p>问题: 如果使用B-Tree存储,内容很大</p>
</li>
<li><p>方案: 删除url列索引,新增一个被索引的url_crc列,使用CRC32做哈希.</p>
</li>
<li><p>sql: select id from t_url where url=”<a href="https://www.google.as/&quot;" target="_blank" rel="noopener">https://www.google.as/&quot;</a> and url_crc=CRC32(“<a href="https://www.google.as/&quot;" target="_blank" rel="noopener">https://www.google.as/&quot;</a>)</p>
</li>
<li><p>结果: MySQL优化器会使用选择性很高体积很小的基于url_crc索引完成查找</p>
</li>
<li><p>缺陷: 需要维护哈希值, crc32表大时会出现大量冲突</p>
</li>
<li><p>注意: 不要使用SHA1和MD5做哈希函数,因为计算出来的哈希值比较长; 必须在where子句中包含常量</p>
</li>
<li><p>插件: 移植自Percona Server的FNV64可以在MySQL中作为哈希函数使用</p>
</li>
</ol>
<h3 id="2-1-4-空间数据索引-R-Tree"><a href="#2-1-4-空间数据索引-R-Tree" class="headerlink" title="2.1.4 空间数据索引(R-Tree)"></a>2.1.4 空间数据索引(R-Tree)</h3><ol>
<li>MyISAM表支持空间索引,可以用作地理数据存储</li>
</ol>
<h3 id="2-1-5-全文索引"><a href="#2-1-5-全文索引" class="headerlink" title="2.1.5 全文索引"></a>2.1.5 全文索引</h3><ol>
<li>全文索引是一种特殊类型索引,查找文本中的关键词,后续讨论</li>
</ol>
<h3 id="2-1-6-其他"><a href="#2-1-6-其他" class="headerlink" title="2.1.6 其他"></a>2.1.6 其他</h3><ol>
<li><p>TokuDB 使用分形树索引, 对于InnoDB的讨论也适用于TokuDB</p>
</li>
<li><p>ScaleDB 使用Patricia tries</p>
</li>
<li><p>InfiniDB和Infobright使用一些特殊的数据结构优化某些特殊的查询</p>
</li>
</ol>
<h2 id="2-2索引的优点"><a href="#2-2索引的优点" class="headerlink" title="2.2索引的优点"></a>2.2索引的优点</h2><ol>
<li><p>减少扫描数据量</p>
</li>
<li><p>避免排序和临时表</p>
</li>
<li><p>将随机I/O变成顺序I/O</p>
</li>
<li><p>对于TB级别的数据,经常会使用块级别的数据技术来替代索引</p>
</li>
</ol>
<h2 id="2-3-高性能的索引策略"><a href="#2-3-高性能的索引策略" class="headerlink" title="2.3 高性能的索引策略"></a>2.3 高性能的索引策略</h2><h3 id="2-3-1-独立的列"><a href="#2-3-1-独立的列" class="headerlink" title="2.3.1 独立的列"></a>2.3.1 独立的列</h3><ol>
<li>索引列不能是表达式一部分或函数参数,否则不能使用索引</li>
</ol>
<h3 id="2-3-2-前缀索引"><a href="#2-3-2-前缀索引" class="headerlink" title="2.3.2 前缀索引"></a>2.3.2 前缀索引</h3><ol>
<li><p>场景: 需要索引很长的字符列,这会让索引变得大且慢</p>
</li>
<li><p>方案: 根据业务找到最适合的前缀长度,创建前缀索引</p>
</li>
<li><p>优点: 索引更小,更快</p>
</li>
<li><p>缺点: MySQL无法使用前缀索引order by 和group by,也无法使用前缀索引做覆盖扫描</p>
</li>
<li><p>常见: 用16进制唯一id存储session id,如果采用长度为8的前缀索引能显著提升性能</p>
</li>
</ol>
<h3 id="2-3-3-多列索引"><a href="#2-3-3-多列索引" class="headerlink" title="2.3.3 多列索引"></a>2.3.3 多列索引</h3><ol>
<li><p>MySQL的索引合并(index merge)策略,一定程度上可以使用多个单列索引定位</p>
</li>
<li><p>where查询条件的列最好使用多列索引而不是单独列单独索引</p>
</li>
</ol>
<h3 id="2-3-4-选择合适的索引顺序"><a href="#2-3-4-选择合适的索引顺序" class="headerlink" title="2.3.4 选择合适的索引顺序"></a>2.3.4 选择合适的索引顺序</h3><ol>
<li><p>将选择性最高的列放在索引最前列</p>
</li>
<li><p>性能不只依赖于所有索引列的选择性,也和查询条件的具体值分布有关,可能需要根据运行频率最高的查询调整索引列顺序</p>
</li>
<li><p>有时需要根据排序,分组和范围条件综合考虑</p>
</li>
</ol>
<h3 id="2-3-5-聚簇索引"><a href="#2-3-5-聚簇索引" class="headerlink" title="2.3.5 聚簇索引"></a>2.3.5 聚簇索引</h3><ol>
<li><p>聚簇索引并不是单独的索引类型,而是一种数据存储方式.叶子页包含行的全部数据,节点页只包含索引列</p>
</li>
<li><p>InnoDB默认使用主键聚集数据,如果没有会选择一个唯一的非空索引作为<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html" target="_blank" rel="noopener">聚簇索引</a></p>
</li>
<li><p>可以把相关数据保存一起,减少磁盘I/O</p>
</li>
<li><p>数据访问更快</p>
</li>
<li><p>插入速度严重依赖插入顺序</p>
</li>
<li><p>更新聚簇索引代价高</p>
</li>
<li><p>可能面临”页分裂”问题,导致占用更多磁盘空间</p>
</li>
<li><p>可能导致全表扫描变慢,由于行比较稀疏或页分裂导致数据存储不连续</p>
</li>
<li><p>二级索引变大,二级索引访问需要两次索引查找</p>
</li>
</ol>
<h3 id="2-3-6-覆盖索引"><a href="#2-3-6-覆盖索引" class="headerlink" title="2.3.6 覆盖索引"></a>2.3.6 覆盖索引</h3><ol>
<li><p>如果一个索引包含所有需要查询的字段的值</p>
</li>
<li><p>覆盖索引必须要存储索引列的值</p>
</li>
<li><p>MySQL不能在索引中执行like 操作,但能在索引中做最左前缀匹配的like比较,因为可以转换为简单的比较操作</p>
</li>
<li><p>延迟关联: 先通过覆盖索引返回需要的主键再通过这些主键关联原表获得需要的行</p>
</li>
</ol>
<h3 id="2-3-7-使用索引扫描做排序"><a href="#2-3-7-使用索引扫描做排序" class="headerlink" title="2.3.7 使用索引扫描做排序"></a>2.3.7 使用索引扫描做排序</h3><ol>
<li><p>只有索引列的顺序和order by 子句的顺序一致时才能使用索引对结果做排序</p>
</li>
<li><p>如果关联多表,则只有当order by子句引用的字段全部为第一个表时才能使用索引排序</p>
</li>
</ol>
<h3 id="2-3-8-压缩索引"><a href="#2-3-8-压缩索引" class="headerlink" title="2.3.8 压缩索引"></a>2.3.8 压缩索引</h3><ol>
<li><p>MyISAM使用前缀压缩减少索引的大小</p>
</li>
<li><p>create table 时通过指定pack_keys控制压缩方式</p>
</li>
</ol>
<h3 id="2-3-9-未使用的索引"><a href="#2-3-9-未使用的索引" class="headerlink" title="2.3.9 未使用的索引"></a>2.3.9 未使用的索引</h3><ol>
<li><p>通过查询INFORMATION_SCHEMA.INDEX_STATISTICES能查到每个索引的使用频率</p>
</li>
<li><p>冗余和重复的索引会降低性能</p>
</li>
</ol>
<h3 id="2-3-10-索引和锁"><a href="#2-3-10-索引和锁" class="headerlink" title="2.3.10 索引和锁"></a>2.3.10 索引和锁</h3><ol>
<li>InnoDB在二级索引上使用共享(读)锁,但访问主键索引需要排他(写)锁,消除了使用覆盖索引的可能</li>
</ol>
<h2 id="2-4-维护索引和表"><a href="#2-4-维护索引和表" class="headerlink" title="2.4 维护索引和表"></a>2.4 维护索引和表</h2><ol>
<li><p>check table 通常能够找出大多数的表和索引的错误</p>
</li>
<li><p>MyISAM表易损坏,InnoDB不容易,损坏可能是硬件或人为错误</p>
</li>
<li><p>MySQL查询优化器通过两个api,一个获取范围大概数据量,一个返回各种类型的数据包括索引基数</p>
</li>
<li><p>减少索引和数据的碎片,B-TREE索引可能碎片化,这会降低效率</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://whales2018.github.io/2018/06/30/mysql-3/" data-id="cjt4acf4l001evjt93bgozxb9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AMQP/">AMQP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《TCP-IP详解卷1》阅读笔记/">《TCP/IP详解卷1》阅读笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/20/ds-1/">1. 链表</a>
          </li>
        
          <li>
            <a href="/2018/09/20/ds-2/">2. 栈</a>
          </li>
        
          <li>
            <a href="/2018/09/20/ds-3/">3. 队列</a>
          </li>
        
          <li>
            <a href="/2018/09/20/ds-4/">4. 字符串</a>
          </li>
        
          <li>
            <a href="/2018/09/20/ds-5/">5. 数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Whales<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>